%*********** Rodzia³ 4 ************
\chapter{Omówienie funkcjonalnoœci biblioteki}
W tym rozdziale szczegó³owo opisane zosta³y funkcjonalnoœci jakie udostêpnia biblioteka.


\section{Inspekcja nadzorowanego programu}
Jak to zosta³o wspomniane we wczeœniejszych rozdzia³ach, aplikacja weryfikuj¹ca kontrakty ma postaæ biblioteki COM i jako taka musi byæ wczeœniej zarejestrowana w systemie. Do tego celu u¿ywana jest aplikacja o nazwie regsrv32.exe, która to jest czêœci¹ narzêdzi dostarczanych wraz z platform¹ .NET.
Zadaniem tego narzêdzia jest pobranie identyfikatora biblioteki i umieszczenie w rejestrze systemu klucza przechowuj¹cego ten identyfikator oraz œcie¿kê w systemie pliku pod która znajduje siê biblioteka.\\

Rozpoczêcie procesu profilowania/weryfikacji aplikacji odbywa siê poprzez uruchomienie programu z linii poleceñ w odpowiednio przygotowanym œrodowisku.
Etap ten polega na ustawieniu zmiennych œrodowiskowych, instruuj¹cych maszynê wirtualn¹ CLR, aby ta wysy³a³a powiadomienia na temat zdarzeñ zachodz¹cych wewn¹trz uruchamianej aplikacji. 
Proces ten wygl¹da w sposób nastêpuj¹cy: 


\begin{lstlisting}
SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={GUID}
\end{lstlisting} 

Powy¿sze zmienne s¹ nastêpnie odczytywane przez œrodowisko uruchomieniowe.
Pierwsza z nich informuje maszynê wirtualn¹, ¿e ta powinna przesy³aæ informacje o zdarzeniach do biblioteki, której po³o¿enie okreœlanie jest przy wykorzystaniu identyfikatora GUID.\\

Liczba i rodzaj wysy³anych powiadomieñ okreœlany jest wewn¹trz biblioteki profiluj¹cej. W szczegó³ach temat ten opisany jest w kolejnym rozdziale.

\section{Kontrakty}
Podstawowym elementem, dziêki któremu mo¿liwa jest weryfikacja metod, jest oczywiœcie mo¿liwoœæ definiowania kontraktu. Jak ju¿ zosta³o wspomniane we wczeœniejszych rozdzia³ach kontrakty definiujemy za pomoc¹ atrybutów. \\

Atrybuty s¹ to znaczniki o charakterze deklaracyjnym zawieraj¹ce
informacjê o elementach programu (np. klasach, typach wyliczeniowych, metodach) przeznaczon¹ dla œrodowiska wykonania programu.
Co jest w tym kontekœcie istotne to i¿ s¹ one pamiêtane jako meta-dane elementu programu.

Definicja atrybutów jest jedynym elementem, wchodz¹cym bezpoœrednio w sk³ad omawianego rozwi¹zania, który musi znajdowaæ siê po stronie weryfikowanej aplikacji.

Jak ju¿ zosta³o wspomniane atrybuty okreœlaj¹ce kontrakt maj¹ postaæ: \\
\begin{lstlisting}[label=AsContract, caption=Ogólna postaæ kontraktu]
AsContract(Warunek pocz¹tkowy, Warunek koñcowy)
\end{lstlisting}
Oba warunki zdefiniowane s¹ poprzez pewne, okreœlone przez u¿ytkownika wyra¿enie. Te z kolei maj¹ postaæ okreœlon¹ przez zadan¹ gramatykê, której definicjê przedstawiono w nastêpnym rozdziale dotycz¹cych implementacji.
Nale¿y tu jednak wspomnieæ, i¿ oba warunki zapisywane s¹ jako ³añcuchy znakowe, tak wiêc konieczne jest ich parsowanie, w celu otrzymania drzewa rozbioru takiego wyra¿enia.
Kolejnym krokiem jest ewaluacja tego drzewa, aby mo¿na by³o okreœliæ czy udekorowana metoda spe³nia na³o¿ony na ni¹ kontrakt.



\section{Metadane}
Metadane w kontekœcie platformy .NET, to dodatkowe informacje opisuj¹ce sk³adowe jêzyka. S¹ usystematyzowanym sposobem reprezentowania wszystkich informacji, których CLI u¿ywa do lokalizowania i ³adowania klas, u³o¿enia obiektów w pamiêci, wywo³ywania metod, translacji jêzyka CIL do kodu natywnego.

Dane te, emitowane przez kompilator, przechowywane s¹ wewn¹trz ka¿dego wykonywalnego programu w postaci binarnej.

\subsection{Reprezentacja metadanych}
W ramach systemu Windows zdefiniowany jest format plików wykonywalnych - PE (eng. Portable Executables), okreœlaj¹cy strukturê jak¹ musi posiadaæ ka¿dy program, aby móg³ byæ uruchomiony w systemie.
%%% RYSUNEK 
Aplikacje przeznaczone na platformê .NET naturalnie równie¿ musz¹ byæ zorganizowane w sposób zgodny z tym standardem.
Jednym z pól w ramach nag³ówka CLI jest offset (RVA) okreœlaj¹cy po³o¿enie zbioru metadanych w ramach pliku wykonywalnego czy biblioteki. 
 
%One field in the CLI header is the RVA for the metadata directory, which gives %access to all the metadata used by the assembly
W sk³ad tego zbioru wchodzi piêæ rodzajów strumieni. W tym kontekœcie, przez pojêcie strumieñ, rozumiany jest jako sekcja w obrêbie metadanych, w której przechowywane s¹ informacje posegregowane wzglêdem ich typu.
Te strumienie to:
\begin{enumerate}
\item \#Strings - zawiera listê napisów, które okreœlaj¹ nazwê programu, metod, parametrów. 
\item \#US (User Strings) - zawiera tablicê wszystkich sta³ych ³añcuchowych definiowanych przez u¿ytkownika. 
\item \#GUID - przechowuje listê wszystkich u¿ytych w aplikacji 128 bitowych wartoœci GUID, m.in. t¹ która jednoznacznie identyfikuje aplikacjê  
%This table contains a list of all of the 128-bit GUIDs used in the application, %including the GUID that is used to uniquely identify this application. Whenever %a program is compiled, it is assigned a new GUID to uniquely identify it. This %is reminiscent of COM, which has similar unique identifiers that were %registered in the registry for the local machine so that this component could %be found.
\item \#~ - ten strumieñ jest tablic¹ tablic. Ka¿da tablica nadrzêdna identyfikowana przy pomocy pojednynczego bajtu o wartoœci od 0x00 do 0x29. Tablice te opisuj¹ metody, pola, parametry, typy.
\item \#Blob - zawiera ci¹gi danych binarnych, które nie mog¹ byæ przedstawione w prosty sposób jako napisy. Dane te wykorzystywane s¹ do opisywania sygnatur metod.
\end{enumerate}

Metadane przechowuj¹ informacje na temat typów definiowanych w ramach programu (klasy, struktury, interfejsy), globalnych funkcji i zmienny. Ka¿da z tych abstrakcyjnych encji niesie ze sob¹ wartoœæ wartoœci typu mdToken (metadata token). Jest ona u¿ywana przez mechanizmy odczytuj¹ce metadane do identyfikacji informacji na temat encji w ramach okreœlonego zasiêgu. 
%Metadata stores declarative information about runtime types (classes, value %types,
%and interfaces), global-functions and global-variable. Each such abstraction in %a
%given metadata scope carries an identity as an mdToken (metadata token), where
%an mdToken is used by the metadata engine to index into a specific metadata %data
%table in that scope. The metadata APIs return a token from each Define method %and
%it is this token that, when passed into the appropriate Get method, is used to %obtain
%its associated attributes.

Token metadanych ma postaæ czterobajtowej wartoœci. Najbardziej znacz¹cy bajt   okreœla typ tokenu, pozosta³e okreœlaj¹ po³o¿enie pozosta³ych informacji w tablicy metadanych.
Dla przyk³adu, wartoœæ 1 przechowywana w MSB (most significant byte) oznacza, i¿ token jest typu mdTypeRef, który oznacza referencjê do typu, a informacje na jego temat s¹ przechowywane w tablicy TypeRef.

%A metadata token is a 4-byte value. The most significant byte (MSB) specifies %the token type and consequently identifies the abstraction and its associated %metadata table. For example, a value of 1 in the MSB means that the token is an %mdTypeRef token, which represents a type reference, and that its metadata is %stored in the TypeRef metadata table; a value of 4 in the MSB corresponds to an %mdFieldDef token. The CorTokenType enumeration is used to specify the token %types.

Pozosta³e, mniej znacz¹ce bajty, oznaczaj¹ identyfikator rekordu (record identifier - RID) i zawieraj¹ w sobie indeks do wiersza w/w tablicy, która okreœlona jest przez wartoœæ najbardziej znacz¹cego bajtu.
Przyk³adowo, token o wartoœci 0x02000007 odnosi siê do siódmego wiersza tablicy TypeRef. Podobnie, wartoœæ 0x0400001A oznacza odwo³anie do wiersza dwudziestego szóstego tabliy FieldDef.
Wiersz zerowy ka¿dej z powy¿szych tablic nigdy nie zawiera w sobie danych, wiêc jeœli identyfikator RID jest równy zeru, to znaczy to, ¿e token jest pusty, ma wartoœæ nil. Taki token zdefiniowany jest dla ka¿dego typu encji, np. wartoœæ 0x10000000 okreœla pusty token mdTypeRefNil.

%The lower three bytes, referred to as the record identifier (RID), contain the %index of the row within the metadata table to which the token's MSB refers. For %example, the metadata token with value 0x02000007 refers to row 7 in the %TypeDef table in the current scope. Similarly, token 0x0400001A refers to row %26 (decimal) in the FieldDef table in the current scope. Row zero of a metadata %table never contains data, so a metadata token whose RID is zero is referred to %as a nil token. The metadata API defines a host of such nil tokens, one for %each token type, such as mdTypeRefNil, with the value 0x01000000.

W poni¿szej tabeli znajduj¹ siê typy tokenów wykorzystywane w ramach aplikacji, typy które opisuj¹ oraz nazwy tablic metadanych. Wszystkie tokeny s¹ pochodnymi typu bazowego - mdToken.

\begin{center}
    \begin{longtable}{ |c | c | p{6cm} |}
    \hline
Token Type & Metadata Table & Abstraction \\ \hline
%mdModule &
%Module &
%Module: A compilation unit, an executable, or some other development unit, %deployment unit, or run-time unit. It is possible (though not required) to %declare attributes on the module as a whole, including a name, a GUID, custom %attributes, and so forth. \\ \hline

%mdModuleRef &
%ModuleRef &
%Module reference: A compile-time reference to a module, which records the %source for type and member imports. \\ \hline

mdTypeDef &
TypeDef &
Type declaration: Declaration of either a runtime reference type (class or interface) or a value type. \\ \hline

%mdTypeRef &
%TypeRef &
%Type reference: Reference to either a runtime reference type or a value type. %In a sense, the collection of type references in a module is the collection of %compile-time import dependencies. \\ \hline

mdMethodDef &
MethodDef &
Method definition: Definition of a method as a member of a class or interface, or as a global module-level method. \\ \hline

mdParamDef &
ParamDef &
Parameter declaration: Definition of an optional data structure that stores additional metadata for the parameter. It is not necessary to emit a data structure for each parameter in a method. However, when there is additional metadata to persist for the parameter, such as marshaling or type-mapping information, an optional parameter data structure can be created. \\ \hline

mdFieldDef &
FieldDef &
Field declaration: Declaration of a variable as a data member of a class or interface, or declaration of a global, module-level variable. \\ \hline

%mdProperty &
%Property &
%Property declaration: Declaration of a property as a member of a class or %interface. \\ \hline

%mdEvent &
%Event &
%Event declaration: Declaration of a named event as a member of a class or %interface. \\ \hline

mdMemberRef &
MemberRef &
Member reference: Reference to a method or field. A member reference is generated in metadata for every method invocation or field access that is made by any implementation in the current module, and a token is persisted in the Microsoft intermediate language (MSIL) stream. There is no runtime support for property or event references. \\ \hline

%mdIfaceImpl &
%IfaceImpl &
%Interface implementation: A specific class’s implementation of a specific %interface. This metadata abstraction enables the storing of information that is %the intersection of that which is specific to neither the class nor the %interface. \\ \hline

%mdMethodImpl &
%MethodImpl &
%Method implementation: A specific class’s implementation of a method that is inherited using interface inheritance. This metadata abstraction enables information to be persisted that is specific to the implementation rather than to the contract. Method declaration information cannot be modified by the implementing class. \\ \hline

mdCustomAttribute &
CustomAttribute &
Custom attribute: An arbitrary data structure associated with any metadata object that can be referenced with an mdToken. (An exception is that custom attributes themselves cannot have custom attributes.) \\ \hline

%mdPermission &
%Permission &
%Permission set: A declarative security permission set associated with mdTypeDef, mdMethodDef, and mdAssembly. For more information, see Adding Declarative Security Support. \\ \hline

%mdTypeSpec &
%TypeSpec &
%Type constructor: A method that obtains a token for a type (such as a boxed value type) that can be used as input to any MSIL instruction that takes a type. \\ \hline 

%mdSignature &
%Signature &
%Stand-alone signature: A local variable signature in the portable executable (PE) file or a method signature that is passed to an MSIL instruction. \\ \hline

%mdString & 
%String &
%User string: A string that is passed to an MSIL instruction. \\ \hline

	\end{longtable}
\end{center}

\subsection{Interpretacja metadanych}

Do zaimplementowania procesu weryfikacji programów przy obranym tutaj podejœciu zachodzi potrzeba interpretacji metadanych. W tym celu potrzebna jest wiedza na temat reprezentacji metadanych i w jaki sposób nale¿y je interpretowaæ.
Jak to zosta³o opisane w poprzednim paragrafie, metadane przechowywane s¹ w tablicach, do których dostêp uzyskiwany jest poprzez token odpowiedniego typu.
W ramach tych tablic, które s¹ czêœci¹ strumienia \#\~, znajduj¹ siê odwo³ania do strumienia \#Blob. W strumieniu tym zawarte s¹ m,in. informacje na temat sygnatury metody.
Sygnatura opisuj¹ca metody zawiera w sobie wszelkie dotycz¹ce jej informacje, m.in. typy argumentów, typ wartoœci zwracanej. Inne rodzaje sygnatur przechowuj¹ informacjê o typach pól klasy, propercji czy te¿ zmiennych lokalnych.
Niezale¿nie od opisywanego elementu jêzyka, sygnatura przechowywana jest jako tablica bajtowa. Istnieje kilka rodzajów sygnatur, z których ka¿da opisuje inny rodzaj encji:
\begin{itemize}
\item MethodRefSig
\item MethodDefSig
\item FieldSig
\item PropertySig
\item LocalVarSig
\item TypeSpec
\item MethodSpec
\end{itemize}

W przypadku biblioteki AsProfiled konieczne jest odczytywanie informacji na temat metod, w tym celu konieczna jest funkcjonalnoœæ sygnatur typu MethodDefSig.

Poni¿ej przedstawiono strukturê tej sygnatury:

\begin{figure}[h]
\centering
\includegraphics[width=5in]{MethodDefSig}
\caption{Struktura sygnatury metadanych opisuj¹cych metodê}
\label{fig:MethodDefSigDiagram}
\end{figure}

Legenda:
\begin{itemize}
\item HASTHIS = 0x20, EXPLICITTHIS = 0x40, DEFAULT = 0x0, VARARG = 0x5 - konwencja w jakiej wywo³ywana jest metoda
\item GENERIC = 0x10 - oznaczenie okreœlaj¹ca czy metoda posiada co najmniej jeden parametr generyczny
\item GenParamCount - oznacza liczbê parametrów generycznych
\item ParamCount - okreœla liczbê parametrów metody
\item RetType - niesie informacjê o typie wartoœci zwracanej
\item Param - opisuje typ ka¿dego parametru metody, w ramach sygnatury element ten powinien wystêpowaæ ParamCount razy
\end{itemize}

Poni¿ej zamieszczono schematy ilustruj¹ce strukturê parametrów metody oraz jej wartoœæ zwrac¹.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{paramdiagram}
\caption{Struktura sygnatury parametru metody}
\label{fig:ParamDiag}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=5in]{rettypediagram}
\caption{Struktura sygnatury okreœlaj¹cej wartoœæ zwracan¹}
\label{fig:RetTypeDiag}
\end{figure}

Powy¿sze ilustracje ró¿ni¹ siê tylko dodatkowym rozga³êzieniem z elementem VOID, który oznacza, i¿ metoda nie zwraca ¿adnej wartoœci.

Element TYPE zdefiniowany jako jedna z wartoœci:\\
\begin{lstlisting}[label=TypeDef, caption=Znaczenie elementu TYPE]
BOOLEAN | CHAR | I1 | U1 | I2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I  | U | 
| VALUETYPE TypeDefOrRefEncoded
| CLASS TypeDefOrRefEncoded
| STRING
| OBJECT
| PTR CustomMod* VOID
| PTR CustomMod* Type
| FNPTR MethodDefSig
| FNPTR MethodRefSig
| ARRAY Type ArrayShape
| SZARRAY CustomMod* Type
\end{lstlisting}
Wartoœci te odpowiadaj¹ typom w ramach platformy .NET.

Innym wa¿nym elementem dla biblioteki AsProfiled jest struktura sygnatury atrybutów, które s³u¿¹ jako noœnik kontraktów. Ilustruj¹ j¹ poni¿szy schemat: 

\begin{figure}[h]
\centering
\includegraphics[width=5in]{customattrib}
\caption{}
\label{fig:CustomAttribDiag}
\end{figure}

Interpretacja tych sygnatur jest podstawowym elementem, który nale¿y wzi¹æ pod uwagê w zadaniu ewaluacji kontraktów.
Dziêki tym informacjom mo¿na okreœliæ typ obiektu, w szczególnoœci argumentów funkcji, co z kolei umo¿liwia odczytanie ich aktualnych wartoœci w momencie wywo³ania funkcji.



Proces ten rozpoczyna siê od pobrania wartoœci tokenu, opisanych w poprzedniej sekcji, odpowiedniego typu. 

Tokeny odpowiedniego rodzaju uzyskiwane s¹ poprzez wywo³ania odpowiednich metod na obiektach implementuj¹cych okreœlone interfejsów.
Dziêki informacj¹ zawartych w metadanych mo¿liwy jest odczyt niezbêdnych informacji. W opisywanej bibliotece zaimplementowano uzyskiwanie nastêpuj¹cych danych: \\

Metody:
GetMethodName
GetCallingConvention
GetArgumentsCount
GetReturnValue
ReadArgumentsValues
GetAttribute

Parametry:
GetType

Typy:
GetName

Atrybuty:
ParseAttributeMetaData






%used to encode the keyword instance in the calling convention, see §15.3
%EXPLICITTHIS = 0x40, used to encode the keyword explicit in the calling %convention, see §15.3
%DEFAULT = 0x0, used to encode the keyword default in the calling convention, %see §15.3
%VARARG = 0x5, used to encode the keyword vararg in the calling convention, see %§15.3
%used to indicate that the method has one or more generic parameters.
%The first byte of the Signature holds bits for HASTHIS, EXPLICITTHIS and %calling convention (DEFAULT, VARARG,
%or GENERIC). These are ORed together.

%GenParamCount is the number of generic parameters for the method. This is a %compressed int32. [Note: For
%generic methods, both MethodDef and MemberRef shall include the GENERIC calling %convention, together with
%GenParamCount; these are significant for binding—they enable the CLI to %overload on generic methods by the
%number of generic parameters they include. end note]
%ParamCount is an integer that holds the number of parameters (0 or more). It %can be any number between 0
%and 0x1FFFFFFF. The compiler compresses it too (see Partition II Metadata %Validation) – before storing into
%the 'blob' (ParamCount counts just the method parameters – it does not include %the method’s return type)
%The RetType item describes the type of the method’s return value (§23.2.11)
%The Param item describes the type of each of the method’s parameters. There %shall be ParamCount instances
%of the Param item (§23.2.10)



%The value of the first byte of a Signature 'blob' indicates what kind of %Signature it is. Its lowest 4 bits hold one
%of the following: C, DEFAULT, FASTCALL, STDCALL, THISCALL, or VARARG (whose %values are defined in §23.2.3),
%which qualify method signatures; FIELD, which denotes a field signature (whose %value is defined in §23.2.4); or
%PROPERTY, which denotes a property signature (whose value is defined in %§23.2.5). This subclause defines the
%binary 'blob' format for each kind of Signature. In the syntax diagrams that %accompany many of the definitions,
%Partition II 153
%shading is used to combine into a single diagram what would otherwise be %multiple diagrams; the
%accompanying text describes the use of shading.
%Signatures are compressed before being stored into the Blob heap (described %below) by compressing the
%integers embedded in the signature. The maximum encodable integer is 29 bits %long, 0x1FFFFFFF. The
%compression algorithm used is as follows (bit 0 is the least significant bit):
%• If the value lies between 0 (0x00) and 127 (0x7F), inclusive, encode as a %one-byte integer (bit 7 is
%clear, value held in bits 6 through 0)
%• If the value lies between 28 (0x80) and 214 – 1 (0x3FFF), inclusive, encode %as a 2-byte integer
%with bit 15 set, bit 14 clear (value held in bits 13 through 0)
%• Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 %clear (value held in bits 28
%through 0)
%• A null string should be represented with the reserved single byte 0xFF, and %no following data


\section{Odczytywanie wartoœci argumentów metod}

%Kolejnym krokiem na drodze do ewaluacji kontraktów jest odczyt wartoœci %argumentów przekazywanych do metody w trakcie jej wywo³ania.
Dziêki informacjom zawartym w metadanych, mo¿liwe jest okreœlenie liczby i typów parametrów przekazywanych do metod. S¹ to dane statyczne, w tym sensie, ¿e s¹ one sta³e w ramach raz zdefiniowanego programu. Z drugiej wartoœci parametrów mog¹ byæ inne dla ka¿dego wywo³ania metody, tak wiêc nie mog¹ w ¿aden sposób stanowiæ czêœci metadanych. Musi wiêc zatem istnieæ osobny mechanizm pozwalaj¹cy na realizacjê tego zadania. \\
W momencie wysy³ania powiadomienia o zajœciu zdarzenia wywo³ania metody, maszyna wirtualna .NET wype³nia strukturê COR\_PRF\_FUNCTION\_ARGUMENT\_INFO, która jest przekazywana do odbiorcy. 
Zdefiniowana jest w nastêpuj¹cy sposób:
\begin{lstlisting}[label=CorPrfFunctionArgumentInfo]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_INFO {
    ULONG numRanges;
    ULONG totalArgumentSize;
    COR_PRF_FUNCTION_ARGUMENT_RANGE ranges[1];
} COR_PRF_FUNCTION_ARGUMENT_INFO;
\end{lstlisting}
Objaœenia:
\begin{itemize}
\item numRanges - The number of blocks of arguments. That is, this value is the number of COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE structures in the ranges array.
\item totalArgumentSize - The total size of all arguments. In other words, this value is the sum of the argument lengths.
\item ranges An array of COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE structures, each of which represents one block of function arguments.
\end{itemize}
Struktura ta reprezentuje argumenty metody, zgodnie z porz¹dkiem od lewej do prawej.
Typ COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE u¿yty w ramach tej struktury okreœlony jest jak nastêpuje:
\begin{lstlisting}[label=lst:CorPrfFunctionArgumentRange]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_RANGE {
    UINT_PTR startAddress;
    ULONG length;
} COR_PRF_FUNCTION_ARGUMENT_RANGE;
\end{lstlisting}
,gdzie\\
\begin{itemize}
\item startAddress - The starting address of the block
\item length - The length of the contiguous block
\end{itemize}

Te dane w po³¹czeniu z informacj¹ o typie argumentu pozwalaj¹ na poprawny odczyt argumentów metody.

\section{Wartoœci zwracane}

Kolejnym elementem jest mo¿liwoœæ weryfikacji kontraktów zawieraj¹cych w sobie odniesienia do wartoœci zwracanej przez metodê.
Takie odniesienia maj¹ tylko sens przy warunkach koñcowych, po odebraniu notyfikacji o zdarzeniu opuszczenia metody. 
Sposób odczytu wartoœci zwracanej jest analogiczny do odczytywania wartoœci parametrów metody. W tym wypadku, odbiorca zdarzenia otrzymuje dostêp do pojedynczego obiektu typu COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE, który to jest rzeczywistym noœnikiem danych, na temat po³o¿enia wartoœci w pamiêci.


\section{Wartoœci pocz¹tkowe}

Termin wartoœci pocz¹tkowe odnosi siê do stanu argumentów w momencie wywo³ania metody. Zgodnie z za³o¿eniami z rozdzia³u pierwszego, biblioteka powinna udostêpniaæ funkcjonalnoœæ definiowania kontraktów z³o¿onych z odwo³añ do pocz¹tkowych wartoœci obiektów. Naturalnie, stan obiektów mo¿e ulec zmianie w czasie dzia³ania metody, nale¿a³o wiêc przedsiêwzi¹æ kroki umo¿liwiaj¹ce tego rodzaju odwo³ania do pocz¹tkowych wartoœci obiektów. 

Jedyn¹ sytuacj¹ jak¹ nale¿a³o rozwa¿yæ, jest w przypadku kontraktów, w których odwo³ania do wartoœci pocz¹tkowych ma miejsce w warunkach koñcowych.
Rzecz jasna, odwo³ania do tych wartoœci nie maj¹ sensu w przypadku warunków pocz¹tkowych, gdy¿ te ewaluowane s¹ zanim sterowanie dojdzie do momentu wykonywania instrukcji wewn¹trz metody, a które mog³yby zmodyfikowaæ stan obiektu. 
Z drugiej strony, co wynika ze specyfiki otrzymywanych powiadomieñ, odczytywanie argumentów jest mo¿liwe tylko w momencie wywo³ywania metody. Co za tym idzie, niezbêdne jest zachowanie stanu obiektu w tym momencie i odwo³ywanie siê do niego w czasie weryfikacji warunków pocz¹tkowych. Dodatkowo, nie wystarczy zachowanie referencji do obiektu. Wynika to z faktu, i¿ pomimo przekazywanie argumentów do metody odbywa siê poprzez kopiowanie, to kopiowana jest tylko referencja do obiektu, a nie sam obiekt. Oczywiœcie kopia referencji dalej wskazuje na ten sam obiekt, wiêc zmieniaj¹c jego stan przy jej u¿ycia, zmieniany jest oryginalny obiekt.
Z tego powodu niezbêdne okazuje siê kopiowanie poszczególnych wartoœci do których wystêpuje odwo³anie w warunkach koñcowych.
Konieczne jest wiêc przeprowadzanie przetwarzania wstêpnego, tzn. w chwili otrzymania powiadomienia o wywo³aniu metody przeprowadzona zostaje analiza zarówno warunków pocz¹tkowych (co jest jasne) i warunków koñcowych kontraktu. W czasie tej analizy warunek koñcowy sprawdzany jest pod k¹tem wystêpowania elementów odnosz¹cych siê do stanu pocz¹tkowego argumentów funkcji. Nastêpnie odpowiednie argumenty poddawane s¹ inspekcji, a nastêpnie wy³uskiwana jest wartoœæ sk³adowej obiektu, do którego odniesienie znajduje siê w warunku koñcowym. Ta wartoœæ zapisywana jest w pamiêci podrêcznej aplikacji, do której dostêp jest mo¿liwy do momentu otrzymania powiadomienia o wyjœciu z zasiêgu weryfikowanej metody, kiedy to mo¿e zostaæ u¿yta do weryfikacji warunku koñcowego.\\

\section{Ograniczenia}
tekst
