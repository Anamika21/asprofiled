%*********** Rodzial 4 ************
\chapter{Szczegó³y implementacji}
W tym rozdziale opisano szczegó³y dotycz¹ce implementacyjne biblioteki.
Poni¿szy diagram ilustruje proces przetwarzania jakiemu poddawany jest kontrakt w celu oceny jego prawdziwoœci.
\begin{figure}[h]
\centering
\includegraphics[width=5in]{evalflow}
\caption{Schemat przedstawiaj¹cy proces ewaluacji kontraktów}
\label{fig:EvalFlowDiagram}
\end{figure}
\clearpage
Proces ewaluacji warunku pocz¹tkowego/koñcowego inicjowany jest poprzez otrzymanie powiadomienia oznaczaj¹cego rozpoczêcie lub zakoñczenie przetwarzania metody (punkt 1 i 2 na diagramie). Elementy 3 oraz 4 reprezentuj¹ poszczególne kroki przetwarzania metadanych przypisanych do aktualnie wykonywanej metody. W ich ramach odczytywane jest wyra¿enie opisuj¹ce kontrakt, które jest nastêpnie parsowane (punkt 5) oraz sygnatura metody zawieraj¹ca m.in. informacje o typach argumentów. Dziêki temu mo¿liwa jest poprawna interpretacja danych binarnych, reprezentuj¹cych wartoœci parametrów metody (punkt 6).
Kolejnym etapem, zale¿nym od rodzaju otrzymanego powiadomienia (punkt 1,2)  jest odczyt wartoœci zwracanej lub zachowanie pocz¹tkowych wartoœci argumentów.
Maj¹c do dyspozycji wszelkie niezbêdne dane, mo¿liwa jest ewaluacja drzewa rozbioru otrzymanego w wyniku operacji z punktu pi¹tego.
\clearpage
\section{Atrybuty jako kontrakty}
Kontrakty definiowane s¹ jako atrybuty, którymi dekorowane s¹ metody.
Definicja atrybutów ogranicza siê do elementarnej klasy, której implementacja zawiera jest w nastêpuj¹cym bloku kodu:
\begin{lstlisting}[label=AsContractAttribute, caption=Definicja atrybutu jako noœnika danych o kontrakcie]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class AsContractAttribute : Attribute
{
  public AsContractAttribute(string preCondition, string postCondition) 
  { }
  
  public string PostCondition { get; set; } 
  
  public string PreCondition { get; set; }
}
\end{lstlisting} 
Pierwsza linia okreœla, i¿ atrybut mo¿e byæ przypisywany tylko do metod oraz mo¿e wystêpowaæ co najwy¿ej jeden raz przy ka¿dej z nich.

Centralnym elementem tej klasy jest dwuparametrowy konstruktor, przyjmuj¹cy dwa napisy jako parametry. W³aœnie te napisy okreœlaj¹ kontrakt. Pierwszy z nich okreœla warunek pocz¹tkowy (\emph{precondition}), a drugi dotyczy warunku koñcowego (\emph{postcondtion})

Wyra¿enia opisuj¹ce kontrakty muszê byæ obliczalne do jednej z dwóch wartoœci: prawdy albo fa³szu, co oznacza odpowiednio, ¿e kontrakt zosta³ lub te¿ nie zosta³ spe³niony. 

\section{Gramatyka kontraktów}
Mo¿liwy zbiór wyra¿eñ, wyra¿alnych poprzez kontrakty, definiowany jest przez gramatykê bezkontekstow¹.
Gramatyka ta zosta³a wykorzystana w aplikacji GOLD Parsing System \cite{website:gold-parser}, która na jej podstawie generuje tablicê stanów dla deterministycznego automatu skoñczonego. Poni¿ej znajduje siê jej definicja :

\begin{lstlisting}[label=lst:Grammar, caption=Gramatyka kontraktów]

"Start Symbol" = <Program>

! Zbiory

{ID Head}      = {Letter} + [_]
{ID Tail}      = {Alphanumeric} + [_]
{String Chars} = {Printable} + {HT} - [\\]
{Number Without Zero} = {Number} - [0]

! Symbole terminalne

Identifier = {ID Head}{ID Tail}*(.{ID Head}{ID Tail}*)*
StringLiteral = '"' ( {String Chars} | '\' {Printable} )* '"'
DecimalNumber = {Number Without Zero}{Number}* | {Number}
BooleanLiteral = 'true' | 'false'
ReturnValue = '@returnValue'(.{ID Head}{ID Tail}*)*
InitialValue = '^'{ID Head}{ID Tail}*(.{ID Head}{ID Tail}*)*

! Symbole nieterminalne i zasady wyprowadzania wyra¿eñ

<Program>           ::= <Boolean Exp>                          
<Boolean Exp>       ::= <Boolean Exp> <Boolean Operator> <Cmp Exp>
                    |   <Cmp Exp>                                 

<Boolean Operator>  ::= '||'
                    |   '&&'

<Cmp Exp>           ::= <Cmp Exp> <Cmp Operator> <Add Exp>    
                    |   <Add Exp>                      
<Cmp Operator>      ::= '>'
                    |   '<'                              
                    |   '<='
                    |   '>='
                    |   '=='
                    |   '!='                       

<Add Exp>           ::= <Add Exp> <Add Operator> <Mult Exp>   
                    |   <Mult Exp>                    
<Add Operator>      ::= '+'
                    |   '-'

<Mult Exp>          ::= <Mult Exp> <Mult Operator> <Negate Exp>  
                    |   <Bit Exp>                               
<Mult Operator>     ::= '*'
                    |   '/'
<Bit Exp>           ::= <Bit Exp> <Bit Operator> <Negate Exp>     
                    |  <Negate Exp>                            
<Bit Operator>      ::= '&'
                    |   '|'
                            
<Negate Exp>        ::= <Negate Operator> <Value>                
                    |  <Value>                                   
<Negate Operator>   ::= '-'
<Value>             ::= Identifier                               
                    |  StringLiteral                             
                    |  DecimalNumber                             
                    |  '(' <Boolean Exp> ')'    
                    |  BooleanLiteral
                    |  ReturnValue                                
                    |  InitialValue

\end{lstlisting}

Poni¿ej przedstawiono kilka przyk³adów wyra¿eñ, które mog¹ byæ zbudowane przy u¿yciu regu³ zawartych w gramatyce:

\begin{lstlisting}[label=ExampleExpr, caption=Przyk³adowe wyra¿enia]
i > 4 || test.inner == 3
i * j == k
str == "napis" || @returnValue == 0 && !false
\end{lstlisting}

Wyra¿enia te nabieraj¹ sensu w momencie kiedy mo¿liwe jest podstawienie wartoœci w miejsce identyfikatorów.

\section{Omówienie i implementacja interfejsów}
Wszystkie interfejsy przedstawione w tym i kolejnych rozdzia³ach zdefiniowane s¹ w bibliotekach, wchodz¹cy w sk³ad SDK platformy .NET. Pe³na dokumentacja wykorzystanych interfejsów programistycznych znajduje siê na stronach MSDN \cite{website:metadataapi, website:profilingapi}.
W tabeli zaprezentowano wykorzystywane nag³ówki wraz z opisem ich zawartoœci :
\begin{center}
\begin{longtable}{ |c | p{6cm} |} \hline
cor.h & G³ówny plik nag³ówkowy zawieraj¹cy API do operowania na metadanych  \\ \hline
corhdr.h & Definicja struktur przechowuj¹cych metadane \\ \hline
corprof.h & Interfejsy profiluj¹ce \\ \hline
\end{longtable}
\end{center}

\emph{AsProfiled} jak ka¿da biblioteka typu COM udostêpnia swoj¹ funkcjonalnoœæ poprzez interfejsy. Niezale¿nie od przeznaczenia biblioteki musi ona przynajmniej implementowaæ interfejs IUnknown, dziêki któremu mo¿liwe jest uzyskanie uchwytu do innych obiektów implementuj¹cych bardziej szczegó³owe interfejsy.
W tym przypadku konieczne jest uzyskanie uchwytu do obiektu implementuj¹cego interfejs ICorProfilerCallback2. 
%\footnote[1]{Pe³na dokumentacja znajduje siê na stronie http://msdn.microsoft.com/en-us/library/ms230825.aspx}. 
To poprzez niego odbywa ca³a komunikacja pomiêdzy maszyn¹ CLR a bibliotek¹ \emph{AsProfiled}. Interfejs ten zawiera kilkadziesi¹t metod, poprzez które maszyna wirtualna mo¿e powiadomiæ odbiorcê o zdarzeniach zachodz¹cych w obrêbie profilowanego programu.
%Pe³na jego definicja znajduje siê w za³¹czniku (A).
Na potrzeby tej pracy wystarczaj¹ce jest omówienie dwóch z nich, mianowicie :

\begin{lstlisting}[label=lst:MainEvents, caption=ICorProfilerCallback2]
STDMETHOD(Initialize)(IUnknown *pICorProfilerInfoUnk);
STDMETHOD(Shutdown)();
\end{lstlisting}

Naturalnie, implementuj¹c dowolny interfejs, niezbêdne jest zdefiniowanie ka¿dej zawartej w nim metody, jednak w przypadku metod, które nie stanowi¹ przedmiotu zainteresowania wystarczaj¹ce jest zwrócenie rezultatu œwiadcz¹cego o poprawnym wykonaniu metody. W tym przypadku, tak¹ wartoœci¹ jest S\_OK (0), standardowo okreœlaj¹c¹ poprawne zakoñczenie wykonywania funkcji.\\

Metody z listingu \ref{lst:MainEvents}, jak sama nazwa wskazuje, s¹ wywo³ywane podczas inicjalizacji biblioteki i w momencie zakoñczenia wykonywania programu.
W ramach funkcji \emph{Shutdown()} zwyczajowo zwalniane s¹ uchwyty do obiektów wykorzystywanych w bibliotece.
Przeciwnie do niej, w metodzie Initialize() tworzone s¹ obiekty, do których dostêp jest potrzebny w kontekœcie ca³ej biblioteki, jest to odpowiednie miejsce na inicjalizacjê globalnych wskaŸników do obiektów wykorzystywanych w trakcie dzia³ania aplikacji.
W tym miejscu nastêpuje te¿ pozyskanie uchwytu do obiektu typu ICorProfilerInfo2, który to udostêpnia zestaw metod pozwalaj¹cych na komunikacjê ze œrodowiskiem CLR, umo¿liwiaj¹cych monitorowanie i uzyskiwanie dodatkowych informacji o programie.\\

Kolejnym krokiem jest zarejestrowanie tego obiektu jako odbiorcy podzbioru zdarzeñ okreœlonych poni¿ej.
\clearpage
 
\begin{lstlisting}[label=Events, caption=Zdarzenia]
COR_PRF_MONITOR_NONE	= 0,
COR_PRF_MONITOR_FUNCTION_UNLOADS	= 0x1,
COR_PRF_MONITOR_CLASS_LOADS	= 0x2,
COR_PRF_MONITOR_MODULE_LOADS	= 0x4,
COR_PRF_MONITOR_ASSEMBLY_LOADS	= 0x8,
COR_PRF_MONITOR_APPDOMAIN_LOADS	= 0x10,
COR_PRF_MONITOR_JIT_COMPILATION	= 0x20,
COR_PRF_MONITOR_EXCEPTIONS	= 0x40,
COR_PRF_MONITOR_GC	= 0x80,
COR_PRF_MONITOR_OBJECT_ALLOCATED	= 0x100,
COR_PRF_MONITOR_THREADS	= 0x200,
COR_PRF_MONITOR_REMOTING	= 0x400,
COR_PRF_MONITOR_CODE_TRANSITIONS	= 0x800,
COR_PRF_MONITOR_ENTERLEAVE	= 0x1000,
COR_PRF_MONITOR_CCW	= 0x2000,
COR_PRF_MONITOR_REMOTING_COOKIE	= 0x4000 | COR_PRF_MONITOR_REMOTING,
COR_PRF_MONITOR_REMOTING_ASYNC	= 0x8000 | COR_PRF_MONITOR_REMOTING,
COR_PRF_MONITOR_SUSPENDS	= 0x10000,
COR_PRF_MONITOR_CACHE_SEARCHES	= 0x20000,
COR_PRF_MONITOR_CLR_EXCEPTIONS	= 0x1000000,
COR_PRF_MONITOR_ALL	= 0x107ffff,
COR_PRF_ENABLE_REJIT	= 0x40000,
COR_PRF_ENABLE_INPROC_DEBUGGING	= 0x80000,
COR_PRF_ENABLE_JIT_MAPS	= 0x100000,
COR_PRF_DISABLE_INLINING	= 0x200000,
COR_PRF_DISABLE_OPTIMIZATIONS	= 0x400000,
COR_PRF_ENABLE_OBJECT_ALLOCATED	= 0x800000,
COR_PRF_ENABLE_FUNCTION_ARGS	= 0x2000000,
COR_PRF_ENABLE_FUNCTION_RETVAL	= 0x4000000,
COR_PRF_ENABLE_FRAME_INFO	= 0x8000000,
COR_PRF_ENABLE_STACK_SNAPSHOT	= 0x10000000,
COR_PRF_USE_PROFILE_IMAGES	= 0x20000000,
\end{lstlisting}

Do realizacji celów przedstawionych przed bibliotek¹ \emph{AsProfiled} potrzebne jest okreœlenie nastêpuj¹cej kombinacji flag:

\begin{lstlisting}
COR_PRF_MONITOR_ENTERLEAVE |
COR_PRF_ENABLE_FUNCTION_RETVAL |
COR_PRF_ENABLE_FUNCTION_ARGS |
COR_PRF_ENABLE_FRAME_INFO
\end{lstlisting}
Pozwala to na otrzymywanie komunikatów na temat wejœcia/wyjœcia do/z metody wraz z danymi na temat jej argumentów i wartoœci zwracanej.

Kolejnym wykorzystywanym interfejsem jest \emph{IMetaDataImport}. Spe³nia kluczow¹ rolê w procesie uzyskiwania informacji na temat typów zdefiniowanych w ramach aplikacji przeznaczonych na platformê .NET.  \emph{IMetaDataImport} zawiera ca³y szereg metod, dziêki którym mo¿liwe jest odszukanie i odczytanie wartoœci metadanych. 
Metody dziel¹ siê na trzy g³ówne kategorie :
\begin{itemize}
\item iteruj¹ce po kolekcjach zawieraj¹cych metadane na temat elementów powi¹zanych z dan¹ klas¹, metod¹, interfejsem, itp.,
%Enumerating collections of items in the metadata scope.
\item odszukuj¹ce okreœlony element programu na podstawie zadanych kryteriów,
%Finding an item that has a specific set of characteristics.
\item pobieraj¹ce informacje na temat konkretnych klas/metod. 
%Getting properties of a specified item.
%\item The Get methods are specifically designed to return single-valued properties of a metadata item. When the property is a reference to another item, a token for that item is returned. Any pointer input type can be NULL to indicate that the particular value is not being requested. To obtain properties that are essentially collection objects (for example, the collection of interfaces that a class implements), use the enumeration methods.
\end{itemize}

W bibliotece \emph{AsProfiled} interfejs \emph{IMetaDataImport} wykorzystywany jest do odczytu metadanych na temat kontraktów oraz metod nimi udekorowanymi.
%Informacje na temat metod uzyskiwane s¹ przy pomocy wywo³ania funkcji 

\section{Odbieranie notyfikacji o zdarzeniach zachodz¹cych w programie}
W zadaniu ewaluacji kontraktów nak³adanych na metody niezbêdne jest aby biblioteka \emph{AsProfiled} mia³a mo¿liwoœæ  odbierania zdarzeñ na temat wywo³ania metody oraz wyjœcia z niej. Jest to realizowane poprzez przekazanie adresów funkcji zwrotnych, do maszyny CLR. Cel ten realizowany jest poprzez wywo³anie metody o sygnaturze

\begin{lstlisting}[label=SetEnterLeaveFunctionHooks2, caption=SetEnterLeaveFunctionHooks2]
HRESULT SetEnterLeaveFunctionHooks2(
    [in] FunctionEnter2    *pFuncEnter,
    [in] FunctionLeave2    *pFuncLeave,
    [in] FunctionTailcall2 *pFuncTailcall);
\end{lstlisting}

na rzecz obiektu implementuj¹cego interfejs ICorProfilerInfo2.
Jako argumenty podawane s¹ wskaŸniki do funkcji zdefiniowanych w ramach biblioteki \emph{AsProfiled}. 
Zgodnie z dokumentacj¹ MSDN, metody te musz¹ zostaæ udekorowane atrybutem \_\_declspec(naked) co oznacza ze kompilator nie generuje dla tych funkcji tzw. prologu ani epilogu, czyli odpowiednich fragmentów kodu, które przywracaj¹ odpowiedni stan stosu oraz rejestrów. Konsekwencj¹ tego jest to, i¿ te czynnoœci musz¹ byæ zaimplementowane w ramach biblioteki.
Po ich wykonaniu mo¿liwe jest przekazanie sterowania do innych funkcji, gdzie przetwarzanie zdarzenia jest kontynuowane.
W ramach \emph{AsProfiled} funkcje te s¹ zadeklarowane w sposób nastêpuj¹cy:

\begin{lstlisting}[label=FunctionEnter, caption=FunctionEnter]
// deklaracja funkcji wywo³ywanej w momencie wejœcia do metody
FunctionEnter(FunctionID functionID, UINT_PTR clientData, COR_PRF_FRAME_INFO func, COR_PRF_FUNCTION_ARGUMENT_INFO *argumentInfo);
\end{lstlisting}
oraz
\begin{lstlisting}[label=FunctionLeave, caption=FunctionLeave]
// deklaracja funkcji wywo³ywanej w momencie wyjœcia z metody
FunctionLeave(FunctionID functionID, UINT_PTR clientData, COR_PRF_FRAME_INFO func, COR_PRF_FUNCTION_ARGUMENT_RANGE *retvalRange);
\end{lstlisting}

,gdzie
\emph{functionID} - identyfikator funkcji, u¿ywany do uzyskania dostêpu do jej metadanych \\
\emph{argumentInfo} - wska¿nik do struktury COR\_PRF\_FUNCTION\_ARGUMENT\_INFO, która okreœla po³o¿enie argumentów funkcji w pamiêci \\
\emph{retvalRange} - wskaŸnik do struktury  COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE, która okreœla po³o¿enie wyniku funkcji w pamiêci \\

Te funkcje maj¹ bezpoœrednie prze³o¿enie na zadanie ewaluacji kontraktów. W ramach funkcji FunctionEnter odbywa siê sprawdzenie warunków pocz¹tkowych, a implementacja FunctionLeave zawiera w sobie sprawdzenie warunków koñcowych.

\section{Odczyt metadanych}
Metadane w kontekœcie platformy .NET, to dodatkowe informacje opisuj¹ce sk³adowe programu. S¹ usystematyzowanym sposobem reprezentowania wszystkich informacji, których CLI u¿ywa do lokalizowania i ³adowania klas, u³o¿enia obiektów w pamiêci, wywo³ywania metod, translacji jêzyka MSIL do kodu natywnego.

Dane te, emitowane przez kompilator, przechowywane s¹ wewn¹trz ka¿dego wykonywalnego programu w postaci binarnej. 

W tym podrozdziale opisano kolejny krok na drodze do ewaluacji kontraktu, jakim jest interpretacja metadanych w celu uzyskania informacji o wywo³ywanych metodach i jej argumentach. Wszelkie informacje na temat metadanych pochodz¹ z specyfikacji Standard ECMA-335 \cite{book:ECMA-335}.

\subsection{Reprezentacja metadanych}
W ramach systemu Windows zdefiniowany jest format plików wykonywalnych - PE (eng. Portable Executables), okreœlaj¹cy strukturê jak¹ musi posiadaæ ka¿dy program, aby móg³ byæ w nim uruchomiony.
%%% RYSUNEK 
Aplikacje przeznaczone na platformê .NET naturalnie równie¿ musz¹ byæ zorganizowane w sposób zgodny z tym standardem.
Jednym z pól w ramach nag³ówka PE jest offset 
okreœlaj¹cy po³o¿enie zbioru metadanych w ramach pliku wykonywalnego czy biblioteki. 
 
W sk³ad tego zbioru wchodzi piêæ rodzajów strumieni. W tym kontekœcie, przez pojêcie strumieñ, okreœlana jest sekcja w obrêbie metadanych, w której przechowywane s¹ informacje posegregowane wzglêdem ich typu.
Te strumienie to:
\begin{enumerate}
\item \#Strings - zawiera listê napisów, które okreœlaj¹ nazwê programu, metod, parametrów. 
\item \#US (User Strings) - zawiera tablicê wszystkich sta³ych ³añcuchowych definiowanych przez u¿ytkownika. 
\item \#GUID - przechowuje listê wszystkich u¿ytych w aplikacji 128 bitowych wartoœci GUID, m.in. t¹ która jednoznacznie identyfikuje aplikacjê  

\item \#\textasciitilde - ten strumieñ jest tablic¹ tablic. Ka¿da tablica nadrzêdna identyfikowana przy pomocy pojedynczego bajtu o wartoœci od 0x00 do 0x29. Tablice wewnêtrzne opisuj¹ metody, pola, parametry, typy.
\item \#Blob - zawiera ci¹gi danych binarnych, które nie mog¹ byæ przedstawione w prosty sposób jako napisy. Dane te wykorzystywane s¹ do opisywania sygnatur metod.
\end{enumerate}

Metadane przechowuj¹ informacje na temat typów definiowanych w ramach programu (klasy, struktury, interfejsy), globalnych funkcji i zmiennych. Ka¿da z tych abstrakcyjnych encji identyfikowana jest przez wartoœæ typu mdToken (metadata token). Jest ona u¿ywana przez mechanizmy odczytuj¹ce metadane do okreœlenia  po³o¿enia w pamiêci informacji na ich temat.

Token metadanych ma postaæ czterobajtowej wartoœci. Najbardziej znacz¹cy bajt   okreœla typ tokenu, pozosta³e okreœlaj¹ po³o¿enie pozosta³ych informacji w tablicy metadanych.
Dla przyk³adu, wartoœæ 1 przechowywana w MSB (most significant byte) oznacza, i¿ token jest typu mdTypeRef, który oznacza referencjê do typu, a informacje na jego temat s¹ przechowywane w tablicy TypeRef.


Pozosta³e, mniej znacz¹ce bajty, oznaczaj¹ identyfikator rekordu (record identifier - RID) i zawieraj¹ w sobie indeks do wiersza w/w tablicy, która okreœlona jest przez wartoœæ najbardziej znacz¹cego bajtu.\\
Przyk³adowo, token o wartoœci 0x02000007 odnosi siê do siódmego wiersza tablicy TypeRef. Podobnie, wartoœæ 0x0400001A oznacza odwo³anie do wiersza dwudziestego szóstego tabliy FieldDef.
Wiersz zerowy ka¿dej z powy¿szych tablic nigdy nie zawiera w sobie danych, wiêc jeœli identyfikator RID jest równy zeru, to znaczy to, ¿e token jest pusty, ma wartoœæ nil. Taki token zdefiniowany jest dla ka¿dego typu encji, np. wartoœæ 0x10000000 okreœla pusty token mdTypeRefNil.


W poni¿szej tabeli znajduj¹ siê typy tokenów wykorzystywane w ramach aplikacji, typy które opisuj¹ oraz nazwy tablic metadanych. Wszystkie tokeny s¹ pochodnymi typu bazowego - mdToken.

\begin{center}

\begin{longtable}{ |c | c | p{4cm} |}
    \hline
Typ tokenu & Nazwa tablicy z metadanymi & Opis \\ \hline

mdTypeDef &
TypeDef &
Token odnosz¹cy siê do typów referencyjnych (klasy i interfejsy) i wartoœciowych (struktury) \\ \hline
%Type declaration: Declaration of either a runtime reference type (class or %interface) or a value type. \\ \hline


mdMethodDef &
MethodDef &
Token odnosz¹cy do informacji opisuj¹cych metody bêd¹ce czêœci¹ klasy lub interfejsu \\ \hline

mdParamDef &
ParamDef &
Typ tokenu, którego wartoœci odnosz¹ siê do informacji okreœlaj¹cych parametry metod \\ \hline

mdFieldDef &
FieldDef &
Odniesienie do metadanych dotycz¹cych sk³adowych  wchodz¹cych w sk³ad klas, interfejsów \\ \hline

mdCustomAttribute &
CustomAttribute &
Zawiera odniesienie do metadanych atrybutów \\ \hline

\caption{Typy tokenów}
\label{mdTokenTypes}
	\end{longtable}
\end{center}

%used to encode the keyword instance in the calling convention, see §15.3
%EXPLICITTHIS = 0x40, used to encode the keyword explicit in the calling %convention, see §15.3
%DEFAULT = 0x0, used to encode the keyword default in the calling convention, %see §15.3
%VARARG = 0x5, used to encode the keyword vararg in the calling convention, see %§15.3
%used to indicate that the method has one or more generic parameters.
%The first byte of the Signature holds bits for HASTHIS, EXPLICITTHIS and %calling convention (DEFAULT, VARARG,
%or GENERIC). These are ORed together.

%GenParamCount is the number of generic parameters for the method. This is a %compressed int32. [Note: For
%generic methods, both MethodDef and MemberRef shall include the GENERIC calling %convention, together with
%GenParamCount; these are significant for binding—they enable the CLI to %overload on generic methods by the
%number of generic parameters they include. end note]
%ParamCount is an integer that holds the number of parameters (0 or more). It %can be any number between 0
%and 0x1FFFFFFF. The compiler compresses it too (see Partition II Metadata %Validation) – before storing into
%the 'blob' (ParamCount counts just the method parameters – it does not include %the method’s return type)
%The RetType item describes the type of the method’s return value (§23.2.11)
%The Param item describes the type of each of the method’s parameters. There %shall be ParamCount instances
%of the Param item (§23.2.10)



%The value of the first byte of a Signature 'blob' indicates what kind of %Signature it is. Its lowest 4 bits hold one
%of the following: C, DEFAULT, FASTCALL, STDCALL, THISCALL, or VARARG (whose %values are defined in §23.2.3),
%which qualify method signatures; FIELD, which denotes a field signature (whose %value is defined in §23.2.4); or
%PROPERTY, which denotes a property signature (whose value is defined in %§23.2.5). This subclause defines the
%binary 'blob' format for each kind of Signature. In the syntax diagrams that %accompany many of the definitions,
%Partition II 153
%shading is used to combine into a single diagram what would otherwise be %multiple diagrams; the
%accompanying text describes the use of shading.
%Signatures are compressed before being stored into the Blob heap (described %below) by compressing the
%integers embedded in the signature. The maximum encodable integer is 29 bits %long, 0x1FFFFFFF. The
%compression algorithm used is as follows (bit 0 is the least significant bit):
%• If the value lies between 0 (0x00) and 127 (0x7F), inclusive, encode as a %one-byte integer (bit 7 is
%clear, value held in bits 6 through 0)
%• If the value lies between 28 (0x80) and 214 – 1 (0x3FFF), inclusive, encode %as a 2-byte integer
%with bit 15 set, bit 14 clear (value held in bits 13 through 0)
%• Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 %clear (value held in bits 28
%through 0)
%• A null string should be represented with the reserved single byte 0xFF, and %no following data

\subsection{Interpretacja metadanych}

Do zaimplementowania procesu weryfikacji programów przy obranym podejœciu zachodzi potrzeba interpretacji metadanych. W tym celu potrzebna jest wiedza na temat reprezentacji metadanych i w jaki sposób nale¿y je interpretowaæ.
Jak to zosta³o opisane w poprzednim paragrafie, metadane przechowywane s¹ w tablicach, do których dostêp uzyskiwany jest poprzez token odpowiedniego typu.
W ramach tych tablic, które s¹ czêœci¹ strumienia \#\~, znajduj¹ siê odwo³ania do strumienia \#Blob. W strumieniu tym zawarte s¹ dane opisuj¹ce sygnatury metod.
Sygnatura opisuj¹ca metody zawiera w sobie wszelkie dotycz¹ce jej informacje, m.in. typy argumentów, typ wartoœci zwracanej. Inne rodzaje sygnatur przechowuj¹ informacjê o typach pól klasy, propercji czy te¿ zmiennych lokalnych.
Niezale¿nie od opisywanego elementu jêzyka, sygnatura przechowywana jest jako tablica bajtowa. Istnieje kilka rodzajów sygnatur, z których ka¿da opisuje inny rodzaj encji:
\begin{itemize}
\item MethodRefSig
\item MethodDefSig
\item FieldSig
\item PropertySig
\item LocalVarSig
\item TypeSpec
\item MethodSpec
\end{itemize}

W przypadku biblioteki \emph{AsProfiled} konieczne jest odczytywanie informacji na temat metod, w tym celu konieczna jest funkcjonalnoœæ sygnatur typu MethodDefSig.
\clearpage
Poni¿ej przedstawiono strukturê tej sygnatury:

\begin{figure}[h]
\centering
\includegraphics[width=5in]{MethodDefSig2}
\caption{Struktura sygnatury metadanych opisuj¹cych metodê}
\label{fig:MethodDefSigDiagram}
\end{figure}

Legenda:
\begin{itemize}
\item HASTHIS = 0x20, EXPLICITTHIS = 0x40, DEFAULT = 0x0, VARARG = 0x5 - konwencja w jakiej wywo³ywana jest metoda
\item GENERIC = 0x10 - oznaczenie okreœlaj¹ca czy metoda posiada co najmniej jeden parametr generyczny
\item GenParamCount - oznacza liczbê parametrów generycznych
\item ParamCount - okreœla liczbê parametrów metody
\item RetType - niesie informacjê o typie wartoœci zwracanej
\item Param - opisuje typ ka¿dego parametru metody, w ramach sygnatury element ten powinien wystêpowaæ ParamCount razy
\end{itemize}
\clearpage
Poni¿ej zamieszczono schematy ilustruj¹ce strukturê parametrów metody oraz jej wartoœæ zwracan¹.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{paramdiagram.ps}
\caption{Struktura sygnatury parametru metody}
\label{fig:ParamDiag}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=5in]{rettypediagram.ps}
\caption{Struktura sygnatury okreœlaj¹cej wartoœæ zwracan¹}
\label{fig:RetTypeDiag}
\end{figure}
\clearpage
Powy¿sze ilustracje ró¿ni¹ siê tylko dodatkowym rozga³êzieniem z elementem VOID, który oznacza, i¿ metoda nie zwraca ¿adnej wartoœci.

Element TYPE zdefiniowany jako jedna z wartoœci:\\
\begin{lstlisting}[label=TypeDef, caption=Znaczenie elementu TYPE]
BOOLEAN | CHAR | I1 | U1 | I2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I  | U | 
| VALUETYPE TypeDefOrRefEncoded
| CLASS TypeDefOrRefEncoded
| STRING
| OBJECT
| PTR CustomMod* VOID
| PTR CustomMod* Type
| FNPTR MethodDefSig
| FNPTR MethodRefSig
| ARRAY Type ArrayShape
| SZARRAY CustomMod* Type
\end{lstlisting}
Wartoœci te odpowiadaj¹ typom w ramach platformy .NET.

Innym wa¿nym elementem istotnym z punktu widzenia biblioteki \emph{AsProfiled} jest struktura sygnatury atrybutów, które s³u¿¹ jako noœnik kontraktów. Ilustruje j¹ poni¿szy schemat: 

\begin{figure}[h]
\centering
\includegraphics[width=5in]{customattrib.ps}
\caption{}
\label{fig:CustomAttribDiag}
\end{figure}

Interpretacja tych sygnatur jest podstawowym elementem, który trzeba wzi¹æ pod uwagê w zadaniu ewaluacji kontraktów.
Dziêki tym informacjom mo¿na okreœliæ typ obiektu, w szczególnoœci argumentów funkcji, co z kolei umo¿liwia odczytanie ich aktualnych wartoœci w momencie wywo³ania funkcji. 

Proces ten rozpoczyna siê od pobrania wartoœci tokenu, którego typ jest jednym z przedstawionych w tabeli \ref{mdTokenTypes}.
Tokeny odpowiedniego rodzaju uzyskiwane s¹ poprzez wywo³ania odpowiednich metod na obiektach implementuj¹cych okreœlone interfejsy.
Dziêki informacjom zawartym w metadanych mo¿liwy jest odczyt niezbêdnych informacji.

\subsection{Odczyt metadanych w bibliotece AsProfiled}

Wywo³anie ka¿dej z metod kontrolowanego programu powoduje wywo³anie metody FunctionEnter. W ramach tej funkcji odczytywane s¹ informacje na temat metody, co do której otrzymano powiadomienie. Jest to mo¿liwe dziêki otrzymywaniu jej identyfikatora w postaci argumentu functionID funkcji FunctionEnter, a nastêpnie wykorzystaniu go do uzyskania dostêpu do metadanych.
Krok ten realizowany jest poprzez wywo³anie metody o sygnaturze
\begin{lstlisting}[label=GetTokenAndMetaDataFromFunction, caption=GetTokenAndMetaDataFromFunction]
HRESULT GetTokenAndMetaDataFromFunction(
    [in]  FunctionID functionId,
    [in]  REFIID     riid,
    [out] IUnknown   **ppImport,
    [out] mdToken    *pToken);
\end{lstlisting}
na rzecz obiektu implementuj¹cego interfejs ICorProfilerInfo2.
Poprzez t¹ metodê uzyskujemy wartoœæ typu mdToken, który jednoznacznie identyfikuje po³o¿enie informacji dotycz¹cych funkcji.
Niezbêdne funkcje pozwalaj¹ce na dostêp i interpretacjê metadanych metody zosta³y zgrupowane w obrêbie klasy \emph{CMethodInfo}, która udostêpnia publiczny interfejs wykonanie operacji wymienionych na listingu \ref{lst:MethodInfo.h}. 
\begin{lstlisting}[label=lst:MethodInfo.h, caption=Interfejs klasy CMethodInfo]
WCHAR* GetMethodName(); // Odczytanie nazwy metody
CorCallingConvention GetCallingConvention(); // Odczyt konwencji wywo³ania
ULONG GetArgumentsCount(); // Pobieranie liczby argumentów
mdTypeDef GetTypeToken(); // Pobranie wartoœci tokenu klasy, w której zawarta jest metoda
%PCCOR_SIGNATURE GetMethodSignatureBlob(); // Adres do 
%mdMethodDef GetMethodToken(); //
CParam* GetReturnValue(); // Pobiera informacje na temat wartoœci zwracanej
std::vector<CParam*>* GetArguments(); // Pobieranie informacji o argumentach funkcji
\end{lstlisting}



\section{Parsowanie wyra¿eñ zawartych w kontraktach}
Wyra¿enia okreœlaj¹ce kontrakt musz¹ byæ zbudowane zgodnie z regu³ami gramatyki przedstawionej w \ref{lst:Grammar} . Pierwszym krokiem na drodze do ich ewaluacji jest proces analizy leksykalnej. W tym celu wykorzystano silnik Astudillo Visual C++ \cite{website:astudillo}, który u¿ywa tablicy stanów wygenerowanych przez aplikacjê GOLD na podstawie zadanej gramatyki.
Biblioteka maj¹c zadane wyra¿enie rozk³ada ja na tokeny zdefiniowane w ramach gramatyki, a nastêpnie tworzy drzewo rozbioru wyra¿enia.
Poni¿ej prezentowany jest efekt rozbioru kilku przyk³adowych wyra¿eñ:

\begin{lstlisting}[label=ParseTree1, caption=Przyk³ad 1]
/*
 * Wyra¿enie: "c.test.member == 31 && divided > 1"
 */

Program
 Boolean Exp
  Cmp Exp
   Value
    Identifier:c.test.member
   Cmp Operator
    ==:==
   Value
    DecimalNumber:31
  Boolean Operator
   &&:&&
  Cmp Exp
   Value
    Identifier:divided
   Cmp Operator
    >:>
   Value
    DecimalNumber:1

\end{lstlisting}

\begin{lstlisting}[label=parseTree2, caption=Przyk³ad 2]
/*
 * Wyra¿enie: "divided / divisor > 0 && @returnValue == 0 || val == \"test\""
 */
Program
 Boolean Exp
  Boolean Exp
   Cmp Exp
    Mult Exp
     Value
      Identifier:divided
     Mult Operator
      /:/
     Value
      Identifier:divisor
    Cmp Operator
     >:>
    Value
     DecimalNumber:0
   Boolean Operator
    &&:&&
   Cmp Exp
    Value
     ReturnValue:@returnValue
    Cmp Operator
     ==:==
    Value
     DecimalNumber:0
  Boolean Operator
   ||:||
  Cmp Exp
   Value
    Identifier:val
   Cmp Operator
    ==:==
   Value
    StringLiteral:"test"
\end{lstlisting}



\section{Inspekcja wartoœci zmiennych}
Kolejnym etapem, koniecznym w procesie wyliczania wartoœci wyra¿eñ zawartych w kontraktach jest wykonywanie podstawieñ wartoœci argumentów pod ich wyst¹pienia.

Niech dane s¹ nastêpuj¹ce definicje klas:
\begin{lstlisting}[label=ClassDef, caption=Przyk³adowe klasy]
class Test {
 public int member = 0;
}

class OtherClass {
 public Test test = new Test();
}
\end{lstlisting}
oraz metoda TestMe, na któr¹ na³o¿ono pewien kontrakt:
\begin{lstlisting}[label=lst:MethodDef, caption=Kontrakt odwo³uj¹cy siê do parametrów metody]
[AsContract("value > 1 && other.test.member == 31", null)]
public int TestMe(int value, OtherClass other)
{ }
\end{lstlisting}
Tak okreœlony kontrakt definiuje warunek pocz¹tkowy, po spe³nieniu którego metoda TestMe mo¿e zostaæ wykonana.
Wyra¿anie zbudowane jest z dwóch warunków logicznych po³¹czonych spójnikiem i (\&\&). Pierwszy warunek\\
\begin{center}
value $>$ 1\\
\end{center}
odnosi siê do pierwszego argumentu funkcji, analogicznie, warunek 
\begin{center}
other.test.member == 31\\
\end{center}
odnosi siê do drugiego parametru metody TestMe(...).
Elementem odró¿niaj¹cym te dwa przypadki jest typ argumentu, do którego wystêpuje odwo³anie.Parametr \emph{value} zalicza siê do kategorii typów wartoœciowych wchodz¹cych w sk³ad jêzyka, zaœ parametr \emph{other} jest typem referencyjnym, zdefiniowanym przez u¿ytkownika. Niesie to ze sob¹ konsekwencje przy zadaniu odczytywania wartoœci argumentów. \\

Wszystkie typy s¹ odwzorowanie na jedn¹ z wartoœci wyliczeniowej \emph{CorElementType} zdefiniowanej wewn¹trz nag³ówka \emph{corHdr.h}.
Poni¿sza tabela przedstawia czêœciow¹ definicjê typu wyliczeniowego, zawê¿on¹ do typów obs³ugiwanych przez bibliotekê AsProfiled.
\begin{center}

\begin{longtable}{ | c | c | c |} \hline
Nazwa & Wartoœæ & Opisywany typ \\ \hline
ELEMENT\_TYPE\_END & 0x0 & Niezdefiniowane \\ \hline
ELEMENT\_TYPE\_VOID & 0x1 & Typ zwracany void \\ \hline
ELEMENT\_TYPE\_BOOLEAN & 0x2 & Typ bool \\ \hline
ELEMENT\_TYPE\_CHAR & 0x3 & Wartoœæ znakowy  \\ \hline
ELEMENT\_TYPE\_I1 & 0x4 & Typ short \\ \hline
ELEMENT\_TYPE\_U1 & 0x5 & Typ short bez znaku \\ \hline
ELEMENT\_TYPE\_I2 & 0x6 & Int \\ \hline
ELEMENT\_TYPE\_U2 & 0x7 & Int bez znaku \\ \hline
ELEMENT\_TYPE\_I4 & 0x8 & Long \\ \hline
ELEMENT\_TYPE\_U4 & 0x9 & Long bez znaku \\ \hline
ELEMENT\_TYPE\_I8 & 0xA & Int64 \\ \hline
ELEMENT\_TYPE\_U8 & 0xB & Int64 bez znaku \\ \hline
ELEMENT\_TYPE\_R4 & 0xC & Float \\ \hline
ELEMENT\_TYPE\_R8 & 0xD & Double \\ \hline
ELEMENT\_TYPE\_STRING & 0xE & String \\ \hline
%ELEMENT\_TYPE\_PTR & 0xF & Unmanaged pointer \\ \hline
%ELEMENT\_TYPE\_BYREF & 0x10 & Managed pointer \\ \hline 
ELEMENT\_TYPE\_VALUETYPE & 0x11 & Typ wartoœciowy \\ \hline
ELEMENT\_TYPE\_CLASS & 0x12 & Typ referencyjny \\ \hline
\caption{Typ wyliczeniowy}
\label{tab:CorElementType}
\end{longtable}
\end{center}

W zale¿noœci od typu aktualnie przetwarzanego obiektu, zmienia siê sposób interpretacji jego wartoœci. Poszczególne przypadki zostan¹ omówione w kolejnych podrozdzia³ach. \\

Oprócz informacji o typie argumentu potrzebne jest pobranie informacji na temat po³o¿enia danych reprezentuj¹cych ich wartoœci. W momencie wysy³ania powiadomienia o zajœciu zdarzenia wywo³ania metody, maszyna wirtualna .NET wype³nia strukturê \\ 
\emph{\_COR\_PRF\_FUNCTION\_ARGUMENT\_INFO}, która jest przekazywana do odbiorcy. 
Jej definicja przedstawia siê w sposób nastêpuj¹cy:
\begin{lstlisting}[label=CorPrfFunctionArgumentInfo]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_INFO {
    ULONG numRanges;
    ULONG totalArgumentSize;
    COR_PRF_FUNCTION_ARGUMENT_RANGE ranges[1];
} COR_PRF_FUNCTION_ARGUMENT_INFO;
\end{lstlisting}
Objaœnienia:
\begin{itemize}
\item \emph{numRanges} - Liczba bloków pamiêci, wewn¹trz których znajduj¹ siê wartoœci argumentów. Okreœla liczbê elementów tablicy typu \\ \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}
\item \emph{totalArgumentSize} - Ca³kowita d³ugoœæ wszystkich argumentów wyra¿ona w bajtach.
\item \emph{ranges} Tablica obiektów typu \\ \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}, z których ka¿da reprezentuje jeden blok pamiêci, gdzie zawarte s¹ wartoœci argumentów metody
\end{itemize}
Struktura ta reprezentuje wartoœci argumentów metody, zgodnie z porz¹dkiem od lewej do prawej.
Typ \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE }u¿yty w ramach tej struktury okreœlony jest jak nastêpuje:
\begin{lstlisting}[label=lst:CorPrfFunctionArgumentRange]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_RANGE {
    UINT_PTR startAddress;
    ULONG length;
} COR_PRF_FUNCTION_ARGUMENT_RANGE;
\end{lstlisting}
,gdzie\\
\begin{itemize}
\item startAddress - Adres pocz¹tku bloku.
\item length - Wielkoœæ bloku pamiêci.
\end{itemize}

Te dane w po³¹czeniu z informacj¹ o typie argumentu pozwalaj¹ na poprawny odczyt argumentów metody. 

\subsection{Typy wbudowane}
W ramach platformy .NET zdefiniowany jest pewien, ograniczony zestaw typów wbudowanych.
W kontekœcie tabeli \ref{tab:CorElementType} s¹ to typy o wartoœciach mniejszych od 0x11. Poza typem \emph{String}, który reprezentowany jest jako\\ \emph{ELEMENT\_TYPE\_STRING} wszystkie s¹ typami wartoœciowymi. Fakt ten ma  znaczenie w momencie odczytu wartoœci obiektów o takim typie.\\
Dla przypomnienia, w momencie wywo³ania metody po stronie weryfikowanego programu biblioteka AsProfiled otrzymuje powiadomienie o tym zdarzeniu. Wraz z nim przekazywana jest struktura \\
 \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE} (zob. \ref{lst:CorPrfFunctionArgumentRange}), która zawiera adres do aktualnej wartoœci parametru. Dla typów wartoœciowych proces odczytania tej wartoœci polega na bezpoœredniej interpretacji bajtów, których liczba okreœlona jest przez pole \emph{length} struktury \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE} znajduj¹cych siê pod adresem wskazywanym przez \emph{startAddress}.
W bibliotece \emph{AsProfiled} zdefiniowana zosta³a klasa \emph{ValueReader}, której odpowiedzialnoœci¹ jest interpretowanie tych danych.
Wszystkie metody, których zadaniem jest odczytanie wartoœci parametrów o typach prostych maj¹ podobn¹ konstrukcjê. 
Przyk³ad:
\begin{lstlisting}[label=TraceInt, caption=Odczytywanie wartoœci typu int]
std::wstring CValueReader::TraceInt(UINT_PTR startAddress)
{
 std::wostringstream stream;
 stream << *(int *)startAddress;
 return stream.str();
}
\end{lstlisting}
Przy odczytywaniu wartoœci innych typów, zmianie ulega tylko linijka, w której odbywa siê rzutowanie na odpowiedni typ. \\

Osobnego rozwa¿enia wymaga odczytywanie parametrów typu \emph{string}. W przeciwieñstwie do wy¿ej opisanych wartoœæ tego typy nie ma z góry okreœlonej d³ugoœci, i choæby z tego powodu nie jest mo¿liwe jego odczytanie w sposób podany powy¿ej.

Interfejs \emph{ICorProfilerInfo2} udostêpnia w tym celu nastêpuj¹c¹ metodê:
\begin{lstlisting}[label=lst:GetStringLayoutLst, caption=Odczytywanie wewnêtrznej struktury napisów]
HRESULT GetStringLayout (
[out] ULONG *pBufferLengthOffset,
[out] ULONG *pStringLengthOffset,
[out] ULONG *pBufferOffset)
\end{lstlisting}
W wyniku wywo³ania tej metody, pod przekazane wskaŸniki, przypisywane s¹ nastêpuj¹ce wartoœci: \\
\begin{itemize}
\item pBufferLengthOffset - okreœla wzglêdne przesuniêcie do adresu w pamiêci, pod którym znajduje siê wartoœæ oznaczaj¹ca liczbê zarezerwowanych bajtów dla danego napisu
\item pStringLengthOffset - wzglêdne przesuniêcie do adresu, w którym okreœlona jest rzeczywista d³ugoœæ napisu
\item pBufferOffser - wzglêdne przesuniêcie adresu, gdzie znajduje siê pierwszy znak napisu
\end{itemize}
Wszystkie przesuniêcia okreœlaj¹ przesuniêcie adresu pamiêci w obrêbie obiektu. 
Adres do miejsca w pamiêci obiektu okreœlony jest przez wartoœæ elementu \emph{startAddress} struktury \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}.
Maj¹c te dane do dyspozycji, biblioteka \emph{AsProfiled} jest w stanie odczytaæ wartoœæ parametrów typu \emph{string}.


\subsection{Odwo³ania do wartoœci sk³adowych obiektów z³o¿onych}
Biblioteka \emph{AsProfiled} pozwala definiowaæ kontrakty, wewn¹trz których znajduj¹ siê odwo³ania do pól z³o¿onych struktur czy klas.
Kontrakt zdefiniowany we fragmencie kodu \ref{lst:MethodDef} przedstawia przyk³adowe wyra¿enie, w którym warunek odnosi siê do pola \emph{member}, które jest sk³adow¹ klasy \emph{Test}, a z kolei obiekt tego typu jest czêœci¹ klasy \emph{other}. Ostatecznie, \emph{member} jest typu prostego \emph{int}, którego wartoœæ odczytywana jest zgodnie z tym co zosta³o przedstawione w poprzednim punkcie. Pozostaje kwestia okreœlenia miejsca w pamiêci, w którym przechowywana jest ta wartoœæ. W tym celu, biblioteka AsProfiled implementuje funkcjonalnoœæ inspekcji obiektów dowolnego typu, pod k¹tem zawierania sk³adowych.\\

Niech wyra¿enie jest postaci jak poprzednio \emph{other.test.member $>$ 31}
Proces sk³ada siê z nastêpuj¹cych kroków:
\begin{enumerate} 
\item Przeszukanie listy parametrów metody w celu odnalezienie tego, do którego odwo³anie znajduje siê w kontrakcie. W tym przyk³adzie szukanym parametrem jest \emph{other}.
\item Pobranie struktury opisuj¹cej u³o¿enie pól wewn¹trz klasy, okreœlaj¹cej element \emph{other}. 
\item Przesuniêcie wskaŸnika do miejsca w pamiêci, w którym znajduj¹ siê dane nale¿¹ce do obiektu wewnêtrznego \emph{test}, zgodnie z informacjami zawartymi w strukturze pobranej w poprzednim kroku.
\end{enumerate}

Krok drugi i trzeci powtarzany jest do momentu, a¿ odnalezione zostanie pole \emph{member}, którego odczyt odbywa siê ju¿ zgodnie z procedur¹ okreœlon¹ w poprzedniej sekcji.

\section{Ewaluacja kontraktów}
Maj¹c do dyspozycji opisane do tej pory funkcjonalnoœci, biblioteka jest ju¿ w stanie wykonaæ zadanie ewaluacji kontraktu.

W tym celu utworzona zosta³a klasa \emph{ClousureEvaluator}. Zawiera ona w sobie dwie metody publiczne, w ramach których ewaluowany jest kontrakt.
\begin{lstlisting}[label=lst:evalMethods, caption=Interfejs klasy ClousureEvaluator]
bool CClousureEvaluator::EvalPreCondition()
bool CClousureEvaluator::EvalPostCondition( COR_PRF_FUNCTION_ARGUMENT_RANGE *retvalRange)
\end{lstlisting}
Pierwsza z metod ewaluuje warunek pocz¹tkowy, druga warunek koñcowy. Do sprawdzenie warunku koñcowego potrzebna jest wartoœæ zwracana z metody, któr¹ to mo¿na odczytaæ wykorzystuj¹c argument \emph{retvalRange}. Uwzglêdnienie wartoœci zwracanej jest jedynym elementem ró¿ni¹cym te metody. Poza tym ci¹g wykonywanych czynnoœci jest taki sam i przebieg zgodnie ze schematem:

\begin{packed_enum}
\item Pobranie obiektu reprezentuj¹cego kontrakt
\item Utworzenie drzewa rozbioru wyra¿enia opisuj¹cego kontrakt
\item Podmiana wêz³ów reprezentuj¹cych parametry na ich wartoœci
\item Ewaluacja drzewa
\end{packed_enum}

\subsection{Zachowywanie wartoœci pocz¹tkowych}
W ramach wyra¿eñ opisuj¹cych kontrakty mo¿liwe s¹ odwo³ania do wartoœci parametrów pocz¹tkowych, które zosta³y przekazane do metody w momencie jej wywo³ania. Wartoœci parametrów mog¹ ulec zmianie w czasie wykonywania metody, dlatego potrzebne jest traktowanie takich odwo³añ w specjalny sposób. Takie odwo³ania maj¹ tylko sens w przypadku wyra¿eñ okreœlaj¹cych warunek koñcowy. Zgodnie z tym co zosta³o powiedziane wczeœniej warunek ten ewaluowany jest po otrzymaniu powiadomienia o opuszczeniu metody, jednak wtedy nie jest ju¿ mo¿liwe uzyskanie wartoœci pocz¹tkowych parametrów, gdy¿ mog³y one zostaæ zmienione w wyniku dzia³añ wewn¹trz metody. Z tego wzglêdu konieczne jest ich skopiowanie w inny obszar pamiêci, sk¹d bêdzie mo¿liwe ich pobranie w dowolnym, póŸniejszym momencie. Dodatkowo, nie wystarczy zachowanie referencji do obiektu. Wynika to z faktu, i¿ pomimo tego, ¿e przekazywanie argumentów do metody odbywa siê poprzez kopiowanie, to kopiowana jest tylko referencja do obiektu, a nie sam obiekt. Oczywiœcie, kopia referencji dalej wskazuje na ten sam obiekt, wiêc zmieniaj¹c stan obiektu przy jej u¿yciu, zmieniany jest oryginalny obiekt.
Z tego powodu niezbêdne jest kopiowanie poszczególnych wartoœci, do których wystêpuje odwo³anie w warunkach koñcowych.
Konieczne jest wiêc przeprowadzanie przetwarzania wstêpnego, tzn. w chwili otrzymania powiadomienia o wywo³aniu metody przeprowadzona zostaje analiza zarówno warunków pocz¹tkowych i warunków koñcowych kontraktu. W czasie tej analizy warunek koñcowy sprawdzany jest pod k¹tem wystêpowania elementów odnosz¹cych siê do stanu pocz¹tkowego argumentów funkcji. Nastêpnie argumenty, do których takie odwo³ania wystêpuj¹ poddawane s¹ inspekcji i wy³uskiwana jest wartoœæ sk³adowej obiektu, do którego odniesienie znajduje siê w warunku koñcowym. Ta wartoœæ zapisywana jest w pamiêci podrêcznej aplikacji, do której dostêp jest mo¿liwy w momencie otrzymania powiadomienia o zakoñczeniu wykonywania weryfikowanej metody, kiedy to mo¿e zostaæ u¿yta do weryfikacji warunku koñcowego.\\

Odpowiednim momentem na zachowanie wartoœci pocz¹tkowych jest chwila, w której przychodzi powiadomienie o rozpoczêciu wykonywania kontrolowanej metody.
T¹ odpowiedzialnoœæ przejmuje obiekt typu \emph{ContractEvaluator}, dziêki informacjom przekazywanym do konstruktora klasy.
\begin{lstlisting}[label=lst:ContractEvaluator, caption=Konstruktor klasy ContractEvaluator]
CContractEvaluator::ContractEvaluator(
 CMethodInfo*, CAttributeInfo*, 
 ICorProfilerInfo2*, COR_PRF_FUNCTION_ARGUMENT_INFO*)
\end{lstlisting}

W ramach bloku inicjalizacyjnego dokonywana jest czêœciowa analiza warunku koñcowego. Wyra¿enie jest badane pod k¹tem wystêpowania identyfikatorów oznaczaj¹cych odwo³anie do wartoœci pocz¹tkowych. Po tym jak takowe zostan¹ odnalezione, nastêpuje przeszukanie listy parametrów metody oraz odczytanie ich aktualnej wartoœci. Niech dana metoda i na³o¿ony na ni¹ kontrakt:
\begin{lstlisting}[label=lst:InitialValues, caption=Wartoœci pocz¹tkowe]
[AsContract(null, "^account.balance + sum == account.balance)]
public void Deposit(Account account, int sum) 
{
 account.balance += sum;
}
\end{lstlisting}

W ramach warunku koñcowego wystêpuje odwo³anie do wartoœci pocz¹tkowej (oznaczanej przez dodanie przedrostka \textasciicircum) pola \emph{balance} obiektu \emph{account}. Fakt ten, zostanie zauwa¿ony podczas przetwarzania wstêpnego kontraktu przez obiekt typu \emph{ContractEvaluator}, a w konsekwencji wartoœæ pocz¹tkowa zostanie zapamiêtana do momentu, w którym metoda bêdzie koñczy³a swoje dzia³anie.

\subsection{Wartoœci zwracane}
Ostatnim elementem, które jest potrzebny do uzyskania w pe³ni funkcjonalnego mechanizmu ewaluacji kontraktów, a w szczególnoœci warunków koñcowych, jest mechanizm pozwalaj¹cy na uwzglêdnianie i obs³ugê wartoœci zwracanych z metody.
Zgodnie z tym co zosta³o napisane w rozdziale \ref{sec:chapter4:section5} wykorzystywana jest tu struktura \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}, która zawiera w sobie wskaŸnik do miejsca w pamiêci, w którym przechowywana jest aktualna wartoœæ, która bêdzie zwrócony z metody.
Odczyt jej nie powoduje ¿adnych komplikacji, gdy¿ wykorzystywane s¹ tu dok³adnie te same mechanizmy co przy interpretacji argumentów metody.
