%*********** Rodzial 4 ************
\chapter{Szczegó³y implementacji}
W tym rozdziale opisano szczegó³y dotycz¹ce implementacyjne biblioteki.
\section{Atrybuty jako kontrakty}
Kontrakty definiowane s¹ jako atrybuty, którymi dekorowane s¹ metody.
Definicja atrybutów ogranicza siê do elementarnej klasy, której ca³a definicja zawarta jest w nastêpuj¹cym bloku kodu:
\begin{lstlisting}[label=AsContractAttribute, caption=Definicja atrybutu jako noœnika danych o kontrakcie]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class AsContractAttribute : Attribute
{
  public AsContractAttribute(string preCondition, string postCondition) 
  { }
  
  public string PostCondition { get; set; } 
  
  public string PreCondition { get; set; }
}
\end{lstlisting} 
Linia nr 1 okreœla, i¿ atrybut mo¿e byæ przypisywany tylko do metod i mo¿e wystêpowaæ tylko jeden raz.

Centralnym elementem tej klasy jest dwuparametrowy konstruktor, przyjmuj¹cy dwa napisy jako parametry. Te w³aœnie napisy okreœlaj¹ kontrakt.

Wyra¿enia opisuj¹ce kontrakty muszê byæ obliczalne do jednej z dwóch wartoœci: prawdy albo fa³szu, co oznacza odpowiednio, ¿e kontrakt zosta³ lub te¿ nie zosta³ spe³niony.

\section{Gramatyka kontraktów}
Mo¿liwy zbiór wyra¿eñ wyra¿alnych poprzez kontrakty definiowany jest poprzez gramatykê bezkontekstow¹.
Gramatyka ta zosta³a wykorzystana w aplikacji GOLD Parsing System, która na tej podstawie generuje tablicê stanów dla deterministycznego automatu skoñczonego. Poni¿ej znajduje siê jej definicja :

\begin{lstlisting}[label=Grammar, caption=Gramatyka kontraktów]

"Start Symbol" = <Program>

! Sets

{ID Head}      = {Letter} + [_]
{ID Tail}      = {Alphanumeric} + [_]
{String Chars} = {Printable} + {HT} - [\\]
{Number Without Zero} = {Number} - [0]

! Terminals

Identifier = {ID Head}{ID Tail}*(.{ID Head}{ID Tail}*)*
StringLiteral = '"' ( {String Chars} | '\' {Printable} )* '"'
DecimalNumber = {Number Without Zero}{Number}* | {Number}
BooleanLiteral = 'true' | 'false'
ReturnValue = '@returnValue'(.{ID Head}{ID Tail}*)*
InitialValue = '^'{ID Head}{ID Tail}*(.{ID Head}{ID Tail}*)*

! Rules

<Program>           ::= <Boolean Exp>                          
<Boolean Exp>       ::= <Boolean Exp> <Boolean Operator> <Cmp Exp>
                    |   <Cmp Exp>                                 

<Boolean Operator>  ::= '||'
                    |   '&&'

<Cmp Exp>           ::= <Cmp Exp> <Cmp Operator> <Add Exp>    
                    |   <Add Exp>                      
<Cmp Operator>      ::= '>'
                    |   '<'                              
                    |   '<='
                    |   '>='
                    |   '=='
                    |   '!='                       

<Add Exp>           ::= <Add Exp> <Add Operator> <Mult Exp>   
                    |   <Mult Exp>                    
<Add Operator>      ::= '+'
                    |   '-'

<Mult Exp>          ::= <Mult Exp> <Mult Operator> <Negate Exp>  
                    |   <Bit Exp>                               
<Mult Operator>     ::= '*'
                    |   '/'
<Bit Exp>           ::= <Bit Exp> <Bit Operator> <Negate Exp>     
                    |  <Negate Exp>                            
<Bit Operator>      ::= '&'
                    |   '|'
                            
<Negate Exp>        ::= <Negate Operator> <Value>                
                    |  <Value>                                   
<Negate Operator>   ::= '-'
<Value>             ::= Identifier                               
                    |  StringLiteral                             
                    |  DecimalNumber                             
                    |  '(' <Boolean Exp> ')'    
                    |  BooleanLiteral
                    |  ReturnValue                                
                    |  InitialValue

\end{lstlisting}

Poni¿ej przedstawiono kilka przyk³adów wyra¿eñ, które mog¹ byæ zbudowane przy u¿yciu regu³ zawartych w gramatyce:



\section{Omówienie i implementacja interfejsów}
Wszystkie interfejsy przedstawione w tym i kolejnych rozdzia³ach zdefiniowane s¹ w bibliotekach, bêd¹cych czêœci¹ frameworku SDK. 
W tabeli zaprezentowano wykorzystywane nag³ówki wraz z opisem ich zawartoœci :
\begin{center}
\begin{longtable}{ |c | p{6cm} |} \hline
cor.h & G³ówny plik nag³ówkowy zawieraj¹cy API do operowania na metadanych  \\ \hline
corhdr.h & Definicja struktur przechowuj¹cych metadane \\ \hline
corprof.h & Interfejsy profiluj¹ce \\ \hline
\end{longtable}
\end{center}

AsProfiled jak ka¿da bibliotek typu COM udostêpnia swoj¹ funkcjonalnoœæ poprzez interfejsy. Niezale¿nie od przeznaczenia biblioteki musi ona przynajmniej implementowaæ interfejs IUnknown, dziêki któremu mo¿liwe jest uzyskanie uchwytu do pozosta³ych interfejsów definiuj¹cych okreœlone funkcjonalnoœci. 
W tym przypadku konieczne jest uzyskanie uchwytu do obiektu implementuj¹cego interfejs ICorProfilerCallback2. To poprzez niego odbywa ca³a komunikacja pomiêdzy maszyn¹ CLR a bibliotek¹ AsProfiled. Interfejs ten zawiera kilkadziesi¹t metod, poprzez które maszyna wirtualna mo¿e powiadomiæ odbiorcê o zdarzeniach zachodz¹cych w obrêbie profilowanego programu.
Pe³na jego definicja znajduje siê w za³¹czniku (A).
Na potrzeby tej pracy wystarczaj¹ce jest omówienie dwóch z nich, mianowicie :\\

\begin{lstlisting}[label=MainEvent, caption=ICorProfilerCallback2]
STDMETHOD(Initialize)(IUnknown *pICorProfilerInfoUnk);
STDMETHOD(Shutdown)();
\end{lstlisting}

Naturalnie, implementuj¹c dowolny interfejs, niezbêdne jest zdefiniowanie ka¿dej zawartej w nim metody, jednak w przypadku metod, które nie stanowi¹ przedmiotu zainteresowania wystarczaj¹ce jest zwrócenie rezultatu œwiadcz¹cego o poprawnym wykonaniu metody. W tym przypadku, tak¹ wartoœci¹ jest S\_OK (0), standardowo okreœlaj¹c¹ poprawne zakoñczenie wykonywania funkcji.\\

Metody listingu (1), jak sama nazwa wskazuje, s¹ wywo³ywane podczas inicjalizacji biblioteki i w momencie zakoñczenia wykonywania programu.
W ramach funkcji Shutdown() zwyczajowo zwalniane s¹ uchwyty do obiektów wykorzystywanych w bibliotece.
Przeciwnie do niej, w metodzie Initialize() tworzone s¹ obiekty, do których dostêp jest potrzebny w kontekœcie ca³ej biblioteki, jest to odpowiednie miejsce na inicjalizacjê globalnych wskaŸników.

W tym miejscu nastêpuje uzyskanie uchwytu do obiektu typu ICorProfilerInfo2, który do udostêpnia zestaw metod pozwalaj¹cych na komunikacje ze œrodowiskiem CLR, umo¿liwiaj¹cych jej monitorowanie i uzyskiwanie dodatkowych informacji o programie.

Kolejnym krokiem jest zarejestrowanie tego obiektu jako odbiorcy okreœlonych zdarzeñ okreœlonych poni¿ej:
 
\begin{lstlisting}[label=Events, caption=Zdarzenia]
COR_PRF_MONITOR_NONE	= 0,
COR_PRF_MONITOR_FUNCTION_UNLOADS	= 0x1,
COR_PRF_MONITOR_CLASS_LOADS	= 0x2,
COR_PRF_MONITOR_MODULE_LOADS	= 0x4,
COR_PRF_MONITOR_ASSEMBLY_LOADS	= 0x8,
COR_PRF_MONITOR_APPDOMAIN_LOADS	= 0x10,
COR_PRF_MONITOR_JIT_COMPILATION	= 0x20,
COR_PRF_MONITOR_EXCEPTIONS	= 0x40,
COR_PRF_MONITOR_GC	= 0x80,
COR_PRF_MONITOR_OBJECT_ALLOCATED	= 0x100,
COR_PRF_MONITOR_THREADS	= 0x200,
COR_PRF_MONITOR_REMOTING	= 0x400,
COR_PRF_MONITOR_CODE_TRANSITIONS	= 0x800,
COR_PRF_MONITOR_ENTERLEAVE	= 0x1000,
COR_PRF_MONITOR_CCW	= 0x2000,
COR_PRF_MONITOR_REMOTING_COOKIE	= 0x4000 | COR_PRF_MONITOR_REMOTING,
COR_PRF_MONITOR_REMOTING_ASYNC	= 0x8000 | COR_PRF_MONITOR_REMOTING,
COR_PRF_MONITOR_SUSPENDS	= 0x10000,
COR_PRF_MONITOR_CACHE_SEARCHES	= 0x20000,
COR_PRF_MONITOR_CLR_EXCEPTIONS	= 0x1000000,
COR_PRF_MONITOR_ALL	= 0x107ffff,
COR_PRF_ENABLE_REJIT	= 0x40000,
COR_PRF_ENABLE_INPROC_DEBUGGING	= 0x80000,
COR_PRF_ENABLE_JIT_MAPS	= 0x100000,
COR_PRF_DISABLE_INLINING	= 0x200000,
COR_PRF_DISABLE_OPTIMIZATIONS	= 0x400000,
COR_PRF_ENABLE_OBJECT_ALLOCATED	= 0x800000,
COR_PRF_ENABLE_FUNCTION_ARGS	= 0x2000000,
COR_PRF_ENABLE_FUNCTION_RETVAL	= 0x4000000,
COR_PRF_ENABLE_FRAME_INFO	= 0x8000000,
COR_PRF_ENABLE_STACK_SNAPSHOT	= 0x10000000,
COR_PRF_USE_PROFILE_IMAGES	= 0x20000000,
\end{lstlisting}

Do realizacji celów przedstawionych przed bibliotek¹ AsProfiled potrzebne jest okreœlenie nastêpuj¹cej kombinacji flag:

\begin{lstlisting}
COR_PRF_MONITOR_ENTERLEAVE |
COR_PRF_ENABLE_FUNCTION_RETVAL |
COR_PRF_ENABLE_FUNCTION_ARGS |
COR_PRF_ENABLE_FRAME_INFO
\end{lstlisting}
Pozwala to na otrzymywanie komunikatów na temat wejœcia/wyjœcia do/z metody wraz z danymi na temat jej argumentów i wartoœci zwracanej.


ICorProfiler\\
IMetaDataImport
Interfejs spe³nia kluczow¹ rolê w procesie uzyskiwania informacji na temat dowolnych encji zdefiniowanych w ramach aplikacji przeznaczonych na platformê .NET. IMetaDataImport zawiera ca³y szereg metod, dziêki którym mo¿liwe jest odszukanie i odczytanie wartoœci metadanych. 
Metoda dziel¹ siê na cztery g³ówne kategorie :
\begin{itemize}
\item Enumerating collections of items in the metadata scope.
\item Finding an item that has a specific set of characteristics.
\item Getting properties of a specified item.
\item The Get methods are specifically designed to return single-valued properties of a metadata item. When the property is a reference to another item, a token for that item is returned. Any pointer input type can be NULL to indicate that the particular value is not being requested. To obtain properties that are essentially collection objects (for example, the collection of interfaces that a class implements), use the enumeration methods.
\end{itemize}

W bibliotece AsProfiled interfejs IMetaDataImport wykorzystywany jest do odczytu metadanych na temat kontraktów oraz metod nimi udekorowanymi.
Informacje na temat metod uzyskiwane s¹ przy pomocy wywo³ania funkcji 

\section{Odbieranie notyfikacji o zdarzeniach zachodz¹cych w programie}
W zadaniu ewaluacji kontraktów nak³adanych na metody, kluczowe jest, aby biblioteka mog³a odbieraæ zdarzenia na temat wywo³ania metody oraz wyjœcia z niej. W tym celu niezbêdne jest przekazanie informacji do maszyny CLR, na temat funkcji, które te zdarzenia bêd¹ obs³ugiwa³y. Cel ten realizowany jest poprzez wywo³anie metody o sygnaturze

\begin{lstlisting}[label=SetEnterLeaveFunctionHooks2, caption=SetEnterLeaveFunctionHooks2]
HRESULT SetEnterLeaveFunctionHooks2(
    [in] FunctionEnter2    *pFuncEnter,
    [in] FunctionLeave2    *pFuncLeave,
    [in] FunctionTailcall2 *pFuncTailcall);
\end{lstlisting}

na rzecz obiektu implementuj¹cego interfejs ICorProfilerInfo2.
Jako argumenty podawane s¹ wskaŸniki do funkcji zdefiniowanej w ramach biblioteki AsProfiled. 
Zgodnie z dokumentacj¹ MSDN, metody te musz¹ zostaæ udekorowane atrybutem \_\_declspec(naked) co oznacza ze kompilator nie generuje dla tych funkcji tzw. prologu ani epilogu, czyli odpowiednich fragmentów kodu, które przywracaj¹ odpowiedni stan stosu oraz rejestrów. 
Po wykonaniu tych czynnoœci mo¿liwe jest przekazanie sterowania do innych funkcji, gdzie przetwarzanie zdarzenia jest kontynuowane.
W ramach AsProfiled funkcje te s¹ zadeklarowane w sposób nastêpuj¹cy:

\begin{lstlisting}[label=FunctionEnter, caption=FunctionEnter]
// deklaracja funkcji wywo³ywanej w momencie wejœcia do metody
FunctionEnter(FunctionID functionID, UINT_PTR clientData, COR_PRF_FRAME_INFO func, COR_PRF_FUNCTION_ARGUMENT_INFO *argumentInfo);
\end{lstlisting}
oraz
\begin{lstlisting}[label=FunctionLeave, caption=FunctionLeave]
// deklaracja funkcji wywo³ywanej w momencie wyjœcia z metody
FunctionLeave(FunctionID functionID, UINT_PTR clientData, COR_PRF_FRAME_INFO func, COR_PRF_FUNCTION_ARGUMENT_RANGE *retvalRange);
\end{lstlisting}

,gdzie
functionID - identyfikator funkcji, który mo¿e byæ u¿yty do uzyskania dostêpu do jej metadanych \\
argumentInfo - wska¿nik do struktury COR\_PRF\_FUNCTION\_ARGUMENT\_INFO, która okreœla po³o¿enie argumentów funkcji w pamiêci \\
retvalRange - wskaŸnik do struktury  COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE, która okreœla po³o¿enie wyniku funkcji w pamiêci \\

Te funkcje maj¹ jasne prze³o¿enie na zadanie ewaluacji kontraktów. W ramach funkcji FunctionEnter odbywa siê sprawdzenie warunków pocz¹tkowych, a implementacja FunctionLeave zawiera w sobie sprawdzenie warunków koñcowych.

\section{Odczyt metadanych}
W tym podrozdziale opisano kolejny krok procesu ewaluacji kontraktu, jakim jest interpretacja metadanych w celu uzyskania informacji o wywo³ywanych metodach i jej argumentach.
Wywo³anie ka¿dej z metod kontrolowanego programu powoduje wywo³anie metody FunctionEnter. W ramach tej funkcji odczytywane s¹ informacje na temat metody, co do której otrzymano powiadomienie. Jest to mo¿liwe dziêki otrzymywaniu jej identyfikatora w postaci argumentu functionID funkcji FunctionEnter, a nastêpnie wykorzystaniu go do uzyskania dostêpu do metadanych.
Krok ten realizowany jest poprzez wywo³anie metody o sygnaturze
\begin{lstlisting}[label=GetTokenAndMetaDataFromFunction, caption=GetTokenAndMetaDataFromFunction]
HRESULT GetTokenAndMetaDataFromFunction(
    [in]  FunctionID functionId,
    [in]  REFIID     riid,
    [out] IUnknown   **ppImport,
    [out] mdToken    *pToken);
\end{lstlisting}
na rzecz obiektu implementuj¹cego interfejs ICorProfilerInfo2.
Poprzez t¹ metodê uzyskujemy wartoœæ typu mdToken, który jednoznacznie identyfikuje po³o¿enie informacji dotycz¹cych funkcji.
Niezbêdne funkcje pozwalaj¹ce na dostêp i interpretacjê metadanych metody zosta³y zgrupowane w obrêbie klasy CMethodInfo, które udostêpnia publiczny interfejs pozwalaj¹cy na nastêpuj¹ce operacje : 

\begin{lstlisting}[label=MethodInfo.h,caption=MethodInfo.h]
WCHAR* GetMethodName();
CorCallingConvention GetCallingConvention();
ULONG GetArgumentsCount();
mdTypeDef GetTypeToken();
PCCOR_SIGNATURE GetMethodSignatureBlob();
mdMethodDef GetMethodToken();
CParam* GetReturnValue();
std::vector<CParam*>* GetArguments();
\end{lstlisting}


\section{Parsowanie wyra¿eñ zawartych w kontraktach}
Wyra¿enia okreœlaj¹ce kontrakt musz¹ byæ zbudowane zgodnie z regu³ami gramatyki podanej w sekcji 5.2. Pierwszym krokiem na drodze do ich ewaluacji jest proces parsowania. W tym celu wykorzystano silnik Astudillo Visual C++ (odniesienie).
Biblioteka maj¹c zadane wyra¿enie rozk³ada ja na tokeny zdefiniowane w ramach gramatyki, a nastêpnie tworzy drzewo rozbioru wyra¿enia.
Poni¿ej prezentowane jest efekt rozbioru kilku przyk³adowych wyra¿eñ:

\begin{lstlisting}[label=ParseTree1, caption=Przyk³ad1]
"c.test.member == 31 && divided > 1"
Program
 Boolean Exp
  Cmp Exp
   Value
    Identifier:c.test.member
   Cmp Operator
    ==:==
   Value
    DecimalNumber:31
  Boolean Operator
   &&:&&
  Cmp Exp
   Value
    Identifier:divided
   Cmp Operator
    >:>
   Value
    DecimalNumber:1

\end{lstlisting}

\begin{lstlisting}[label=parseTree2, caption=Przyk³ad2]
"divided / divisor > 0 && @returnValue == 0 || val == \"test\""
Program
 Boolean Exp
  Boolean Exp
   Cmp Exp
    Mult Exp
     Value
      Identifier:divided
     Mult Operator
      /:/
     Value
      Identifier:divisor
    Cmp Operator
     >:>
    Value
     DecimalNumber:0
   Boolean Operator
    &&:&&
   Cmp Exp
    Value
     ReturnValue:@returnValue
    Cmp Operator
     ==:==
    Value
     DecimalNumber:0
  Boolean Operator
   ||:||
  Cmp Exp
   Value
    Identifier:val
   Cmp Operator
    ==:==
   Value
    StringLiteral:"test"
\end{lstlisting}



\section{Inspekcja wartoœci zmiennych}
Jednym z etapów koniecznych w procesie wyliczania wartoœci wyra¿eñ zawartych w kontraktach jest wykonywanie podstawieñ wartoœci argumentów pod ich wyst¹pienia.

Niech dane s¹ nastêpuj¹ce definicje klas:
\begin{lstlisting}[label=ClassDef, caption=Przyk³adowe klasy]
class Test {
 public int member = 0;
}

class OtherClass {
 public Test test = new Test();
}
\end{lstlisting}
oraz metoda TestMe, na któr¹ na³o¿ono pewien kontrakt:
\begin{lstlisting}[label=MethodDef, caption=Kontrakt odwo³uj¹cy siê do parametrów metody]
[AsContract("value > 1 && other.test.member == 31", null)]
public int TestMe(int value, OtherClass other)
{ }
\end{lstlisting}
Tak okreœlony kontrakt definiuje warunek pocz¹tkowy, po spe³nieniu którego metoda TestMe mo¿e zostaæ wykonana.
Wyra¿anie zbudowane jest z dwóch warunków logicznych po³¹czonych spójnikiem i (\&\&). Pierwszy warunek\\
\begin{center}
value > 1\\
\end{center}
odnosi siê do pierwszego argumentu funkcji, analogicznie, warunek 
\begin{center}
other.test.member == 31\\
\end{center}
odnosi siê do drugiego parametru metody TestMe(...).
Elementem odró¿niaj¹cym te dwa przypadki jest typ argumentu, do którego wystêpuje odwo³anie.Parametr \emph{value} zalicza siê do kategorii typów wartoœciowych wchodz¹cych w sk³ad jêzyka, a parametr \emph{other} jest typem referencyjnym, zdefiniowanym przez u¿ytkownika.
Wszystkie typy s¹ odwzorowanie na jedn¹ z wartoœci wyliczeniowej \emph{CorElementType} zdefiniowanej wewn¹trz nag³ówka \emph{corHdr.h}.
Poni¿sza tabela przedstawia czêœciow¹ definicjê typu wyliczeniowego, zawê¿on¹ do typów obs³ugiwanych przez bibliotekê AsProfiled.
\begin{center}

\begin{longtable}{ | c | c | c |} \hline
Nazwa & Wartoœæ & Opisywany typ \\ \hline
ELEMENT\_TYPE\_END & 0x0 & Niezdefiniowane \\ \hline
ELEMENT\_TYPE\_VOID & 0x1 & Typ zwracany void \\ \hline
ELEMENT\_TYPE\_BOOLEAN & 0x2 & Typ bool \\ \hline
ELEMENT\_TYPE\_CHAR & 0x3 & Wartoœæ znakowy  \\ \hline
ELEMENT\_TYPE\_I1 & 0x4 & Typ short \\ \hline
ELEMENT\_TYPE\_U1 & 0x5 & Typ short bez znaku \\ \hline
ELEMENT\_TYPE\_I2 & 0x6 & Int \\ \hline
ELEMENT\_TYPE\_U2 & 0x7 & Int bez znaku \\ \hline
ELEMENT\_TYPE\_I4 & 0x8 & Long \\ \hline
ELEMENT\_TYPE\_U4 & 0x9 & Long bez znaku \\ \hline
ELEMENT\_TYPE\_I8 & 0xA & Int64 \\ \hline
ELEMENT\_TYPE\_U8 & 0xB & Int64 bez znaku \\ \hline
ELEMENT\_TYPE\_R4 & 0xC & Float \\ \hline
ELEMENT\_TYPE\_R8 & 0xD & Double \\ \hline
ELEMENT\_TYPE\_STRING & 0xE & String \\ \hline
%ELEMENT\_TYPE\_PTR & 0xF & Unmanaged pointer \\ \hline
%ELEMENT\_TYPE\_BYREF & 0x10 & Managed pointer \\ \hline 
ELEMENT\_TYPE\_VALUETYPE & 0x11 & Typ wartoœciowy \\ \hline
ELEMENT\_TYPE\_CLASS & 0x12 & Typ referencyjny \\ \hline
\caption{Typ wyliczeniowy}
\label{tab:CorElementType}
\end{longtable}
\end{center}

W kolejnych podrozdzia³ach opisano, w jaki sposób typ parametru wp³ywa na podejœcie odczytywania ich wartoœci.


\subsection{Typy wbudowane}
W ramach platformy .NET definiowany pewien zbiór wbudowanych typów, które stanowi¹ podstawê do definiowania wszystkich pozosta³ych. 
W kontekœcie tabeli \ref{tab:CorElementType} s¹ to typy o wartoœciach mniejszych od 0x11. Poza typem \emph{String}, który reprezentowany jest jako \emph{ELEMENT\_TYPE\_STRING} wszystkie s¹ typami wartoœciowymi. Ma to kluczowe znaczenie w momencie odczytu wartoœci obiektów o takim typie.\\
Dla przypomnienia, w momencie wywo³ania metody po stronie weryfikowanego programu biblioteka AsProfiled otrzymuje powiadomienie o tym zdarzeniu. Wraz z nim przekazywana jest struktura \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE} (zob. \ref{lst:CorPrfFunctionArgumentRange}), która zawiera adres do aktualnej wartoœci parametru. Dla typów wartoœciowych proces odczytania tej wartoœci polega na bezpoœredniej interpretacji bajtów, których liczba okreœlona jest przez polae \emph{lenght} struktury \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE} znajduj¹cych siê pod adresem wskazywanym przez \emph{startAddress}.
W bibliotece AsProfiled zdefiniowana zosta³a klasa \emph{CValueReader}, której odpowiedzialnoœci¹ jest interpretowanie tych danych.
Wszystkie metody, których zadaniem jest odczytanie wartoœci parametrów o typach prostych maj¹ podobn¹ konstrukcjê. 
Przyk³ad:
\begin{lstlisting}[label=TraceInt, caption=Odczytywanie wartoœci typu int]
std::wstring CValueReader::TraceInt(UINT_PTR startAddress)
{
 std::wostringstream stream;
 stream << *(int *)startAddress;
 return stream.str();
}
\end{lstlisting}
Przy odczytywaniu wartoœci innych typów, zmianie ulega tylko linijka, w której odbywa siê rzutowanie. \\

Osobnego rozwa¿enia wymaga odczytywanie parametrów typu \emph{string}. W przeciwieñstwie do wy¿ej opisanych wartoœæ tego typy nie ma z góry okreœlonej d³ugoœci, nie choæby z tego powodu nie jest mo¿liwe jego odczytanie.

Interfejs \emph{ICorProfilerInfo2} udostêpnia w tym celu nastêpuj¹c¹ metodê:
\begin{lstlisting}[label=lst:GetStringLayoutLst, caption=Odczytywanie wewnêtrznej struktury napisów]
HRESULT GetStringLayout (
[out] ULONG *pBufferLengthOffset,
[out] ULONG *pStringLengthOffset,
[out] ULONG *pBufferOffset)
\end{lstlisting}
W wyniku wywo³ania tej metody, pod przekazane wskaŸniki, przypisywane s¹ nastêpuj¹ce wartoœci: \\
\begin{itemize}
\item pBufferLengthOffset - okreœla wzglêdne przesuniêcie do adresu w pamiêci, pod którym znajduje siê wartoœæ oznaczaj¹ca liczbê zarezerwowanych bajtów dla danego napisu
\item pStringLengthOffset - wzglêdne przesuniêcie do adresu, w którym okreœlona jest rzeczywista d³ugoœæ napisu
\item pBufferOffser - wzglêdne przesuniêcie adresu, gdzie znajduje siê pierwszy znak napisu
\end{itemize}
Wszystkie przesuniêcia okreœlaj¹ przesuniêcie adresu pamiêci w obrêbie obiektu. 
Ta wartoœæ pobiera jest z pola \emph{startAddress} struktury \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}.
Maj¹c te dane do dyspozycji, biblioteka AsProfiled jest w stanie odczytaæ parametrów typu \emph{string}.
\subsection{Typy definiowane przez u¿ytkownika}


\section{Ewaluacja kontraktów}
Drzewo rozbioru
\subsection{Ramki funkcji}
\subsection{Zachowywanie wartoœci pocz¹tkowych}
