\chapter{Porównanie z innymi bibliotekami}
W tej czêœci opisano dwa rozwi¹zania realizuj¹ce podejœcie programowania kontraktowego. Podobnie jak biblioteka AsProfiled s¹ one przeznaczone dla programów pracuj¹cych w ramach platformy .NET.

\section{Code Contracts}
Code Contracts to kompleksowe rozwi¹zanie firmy Microsoft, pocz¹tkowe tworzone w ramach komórki badawczej Mirosoft Research. Obecnie jest ju¿ dostêpna na rynku w pe³ni funkcjonalna wersja tego zestawu narzêdzi i wchodz¹ one w sk³ad œrodowiska programistycznego Visual Studio 2010. \\

Z perspektywy implementacyjnej w ramach \emph{Code Contracts} zastosowano inne podejœcie, od tego, które reprezentowane jest przez AsProfiled.
Dla przypomnienia, AsProfiled stanowi zewnêtrzn¹ bibliotekê, do której odwo³ania wystêpuj¹ na poziomie maszyny wirtualnej .NET. Sprawdzany program nie ma œwiadomoœci istnienia tej biblioteki, a jedynym elementem zewnêtrznym jest klasa definiuj¹ca atrybuty, poprzez który reprezentowany jest kontrakt.
W przypadku u¿ycia \emph{Code Contracts}, kontrolowany program (biblioteka) odwo³uje siê bezpoœrednio do metod zdefiniowanych w ramach przestrzeni nazw \emph{System.Diagnostics.Contracts}. 

Razem z bibliotek¹ dostarczane jest narzêdzie \emph{ccrewrite.exe}, które jest kluczowym elementem w zadaniu sprawdzania poprawnoœci kontraktów w czasie dzia³ania aplikacji. Narzêdzie to, dostaj¹c na wejœciu skompilowan¹ bibliotekê,
odnajduje wszelkie odwo³ania do metod zawartych w przestrzeni nazw \emph{System.Diagnostics.Contracts}, a nastêpnie modyfikuje jej kod poœredni.
Transformacja ta polega na zamianie wszystkich odwo³añ do definicji kontraktów, na odpowiadaj¹ce im bloki kodu. Na przyk³ad, odwo³ania do wartoœci pocz¹tkowych 
bêd¹ przet³umaczone na ci¹g operacji w wyniku których zostan¹ one skopiowane i zachowane, dziêki czemu bêd¹ mog³y byæ u¿yte w warunku koñcowym.

Przepisywanie kodu skompilowanej biblioteki przy u¿yciu powy¿szego narzêdzia to g³ówna i zasadnicza ró¿nica w podejœciu w stosunku do tego co zosta³o wykorzystane w \emph{AsProfiled}. \\

 
Narzêdzie \emph{Ccrewrite.exe} poprzez przepisywanie kodu umo¿liwia umieszczenie wszystkich deklaracji kontraktów na pocz¹tku metody.
Zmodyfikowany kod bêdzie zawiera³ sprawdzenie kontraktu koñcowego we wszystkich miejscach, w których mo¿liwe jest opuszczenie metody.  \\

Z punktu widzenia u¿ytkownika, zasadnicza ró¿nic¹, w stosunku do biblioteki AsProfiled jest sposób okreœlania kontraktów.
W tym wypadku s¹ one definiowane jako wywo³ania statycznych metod klasy \emph{Contract}, przy czym kontrakt podawany jako ich argument, w postaci wyra¿enia logicznego. Poprawnym wyra¿eniem jest dowolne wyra¿enie zgodne z regu³ami ich budowania w ramach ustalonego jêzyka programowania.
Podejœcie to ma zasadnicz¹ zaletê, mianowicie kontrakty s¹ silnie typowane.
Poni¿szy wycinek kodu ilustruje dotychczasowy opis:

\begin{lstlisting}[label=lst:CodeContracts1, caption=CodeContracts - sposób u¿ycia]

public int Test(int arg1, int arg2)
{
 Contract.Requires(PreCondition);
 Contract.Ensures(PostCondition);
 int result = arg1 * arg2;
 return result;
}
\end{lstlisting}

Przy pomocy metod \emph{Requires} i \emph{Ensure} okreœlane s¹ odpowiednio warunki pocz¹tkowe i warunki koñcowe. Ich argumentem mo¿e byæ dowolnie skomplikowane wyra¿enie obliczalne do wartoœci logicznej, a ka¿da z tych metod mo¿e byæ wywo³ana dowoln¹ liczbê razy.

Dla porównania, poni¿ej zestawiono deklaracje tego samego kontraktu pocz¹tkowego w ramach bibliotek.
\emph{Code.Contracts} i \emph{AsProfiled}:

\begin{lstlisting}[label=CCvsAsP1, caption=Deklaracja kontraktu]
// AsProfiled
[AsContract("arg1 != 0 && arg2 != 0", "@returnValue != 0")]
public int Div(int arg1, int arg2)
{
 return arg1 / arg2;
}

// Code.Contracts
public int Div(int arg1, int arg2)
{
 Contract.Requires(arg1 != 0);
 Contract.Requires(arg2 != 0);
 Contract.Ensures(Contract.Result<int>() != 0);
 return arg1 / arg2;
}
\end{lstlisting}

W tym przyk³adnie, poza wczeœniej wymienionymi metodami \emph{Requires} i \emph{Ensures}, znajduje siê wywo³anie metody \emph{Contract.Results \textless int\textgreater()}.
Jest to odpowiednik elementu \emph{@returnValue} w obrêbie kontraktów AsContracts, a wiêc oznacza odwo³anie do wartoœci zwracanej z metody.\\

Wspóln¹ cech¹ bibliotek \emph{Code Contracts} oraz \emph{AsProfiled} jest mo¿liwoœæ odwo³ywania siê do wartoœci pocz¹tkowych argumentów metody.
W ramach kontraktów \emph{AsContracts} odwo³anie do wartoœci pocz¹tkowych oznaczane s¹ przez \emph{\^{}nazwaArgumentu}, z kolei tutaj t¹ rolê pe³ni metoda \linebreak 
\emph{Contracts.OldValue\textless T \textgreater(T value)}.
Za zachowywanie tych wartoœci odpowiedzialny jest kod wygenerowany przez \emph{ccrewrite.exe}. 
Poni¿szy kod ilustruje wykorzystanie tej funkcjonalnoœci.

\begin{lstlisting}[label=lst:CodeContracts2, caption=Wykorzystanie wartoœci pocz¹tkowych]
public void Deposit(Account account, int amount)
{
 Contract.Requires(amount > 0);
 Contract.Ensures(account.Balance == Contract.OldValue(account.Balance) + amount); 
 account.Balance += amount;
}
\end{lstlisting}
\cleardoublepage
Odpowiednik powy¿szego kontraktu w ramach biblioteki AsProfiled jest nastêpuj¹cy:
\begin{lstlisting}[label=lst:AsContract, caption=Wartoœci pocz¹tkowe w AsContract]
[AsContract("amount > 0", "^account.Balance + amount == account.Balance")]
public void Deposit(Account account, int amount)
{
 account.Balance += amount;
}
\end{lstlisting} 

Dodatkowo \emph{Code Contracts} udostêpnia kilka innych, u¿ytecznych funkcjonalnoœci, których nie posiada biblioteka \emph{AsProfiled}. S¹ to miêdzy innymi:
\begin{enumerate}
\item Contract.Requires\textless TException\textgreater( bool condition ) - w przypadku, niespe³nienia kontraktu, rzucany jest wyj¹tek okreœlonego typu
\item Contract.EnsuresOnThrow\textless TException\textgreater( bool condition ) - okreœla warunek koñcowy jaki musi byæ zachowany w przypadku wyst¹pienia wyj¹tku typu TException
\item Deklaracja niezmiennków, czyli warunków nak³adanych na obiekt, które s¹ sprawdzane przed i po wywo³aniu ka¿dej z publicznych metod obiektu.

\begin{lstlisting}[label=CodeContracts3, caption=Niezmiennik obiektu]
[ContractInvariantMethod]
private void ObjectInvariant () 
{
 Contract.Invariant ( condition1 );
 Contract.Invariant ( condition2 );
}
\end{lstlisting}
Metoda oznaczona atrybutem \emph{[ContractInvariantMehtod]} jest wywo³ywana przez odpowiedni kod wygenerowany przez narzêdzie \emph{ccrewrite.exe} 
\end{enumerate}

Podsumowuj¹c, \emph{Code Contracts} w obecnej postaci jest dopracowanym rozwi¹zaniem, o czym œwiadczy fakt, i¿ jest czêœci¹ oficjalnej dystrybucji platformy .NET 4.0. Zasadnicz¹ ró¿nic¹ w stosunku do biblioteki AsProfiled jest œrodowisko, w którym kontrakty s¹ ewaluowane. W Code Contracts kontrakty wykonuj¹ siê jako kod zarz¹dzany, w AsProfiled s¹ one pod kontrol¹ niezarz¹dzanego kodu profilera.
Du¿¹ zalet¹ w stosunku do biblioteki AsProfiled, poza bogatsz¹ funkcjonalnoœci¹, jest silne typowanie wyra¿eñ okreœlaj¹cych warunki. U³atwia to ich pisanie oraz uniemo¿liwia tworzenie niepoprawnych w sensie sk³adniowym warunków. 

\section{LinFu.Contracts}
LinFu.Contracts wchodzi w sk³ad bibliotek zgrupowanych w ramach projektu LinFu, stworzonego przez Philipa Laureano a udostêpnianego na zasadach wolnego oprogramowania. U podstaw tej biblioteki le¿y mechanizm generowania dynamicznych obiektów poœrednicz¹cych (ang. \emph{dynamic proxy}), które pozwalaj¹ na przechwytywanie wywo³añ metod na docelowym obiekcie. 
Ten w³aœnie mechanizm wykorzystywany jest przy realizacji podejœcia programowania kontraktowego. \\
Proces tworzenia obiektu poœrednicz¹cego odbywa siê poprzez metodê \emph{CreateProxy\textless T\textgreater(IInvokeWrapper wrapper)} nale¿¹cej do klasy \emph{ProxyFactory}. W rezultacie zwracany jest uchwyt to obiektu typu \emph{T}, przy czym ka¿de odwo³anie do jego metod bêdzie przechwytywane przez obiekt implementuj¹cy interfejs \emph{IInvokeWrapper}.
Interfejs ten okreœlony jest w sposób nastêpuj¹cy:

\begin{lstlisting}[label=IInvokeWrapper, caption=Interfejs IInvokeWrapper]
public interface IInvokeWrapper
{
 void BeforeInvoke(InvocationInfo info);
 object DoInvoke(InvocationInfo info);
 void AfterInvoke(InvocationInfo info, object returnValue);
}
\end{lstlisting}
Powy¿sze metody wywo³ywane s¹ przez obiekt poœrednicz¹cy w momentach zgodnych z ich nazewnictwem, tzn. \emph{BeforeInvoke}, \emph{AfterInvoke} oznaczaj¹ moment przed i po wywo³aniu, natomiast \emph{DoInvoke} to w³aœciwe wywo³anie. Nale¿y zaznaczyæ i¿ metoda na obiekcie docelowym mo¿e, ale nie musi byæ wykonana, decyduje o tym implementacja metody \emph{DoInvoke}. 
Dla jasnoœci prezentowany jest poni¿szy przyk³ad:
\begin{lstlisting}[label=DynamicProxy, caption=Tworzenie obiektu poœredniego]
// Klasa pocz¹tkowa 
public class Worker 
{
 public virtual void Do() 
 {
  Console.WriteLine("Metoda Do()");
 }
}

public class WrappedWorker : IInvokeWrapper 
{
 object _target;
 public WrappedWorker(object target)
 {
  _target = target;
 }
 void BeforeInvoke(InvocationInfo info) 
 {
  Console.WriteLine("Przed wywo³aniem metody Do()");
 }

 object DoInvoke(InvocationInfo info)
 {
  Console.WriteLine("Wywo³anie metody Do()");
  object result = null;
  // W celu wywo³ania oryginalnej metody Do() nale¿y 
  // usun¹æ komentarz z nastêpnej linii:
  // result = info.TargetMethod.Invoke(_target, info.Arguments);
  return result;
 }

 void AfterInvoke(InvocationInfo info, object returnValue) 
 {
    Console.WriteLine("Po wywo³aniu metody Do()");
 }
}

public class Program 
{
 public static void Main(string[] args)
 {
  ProxyFactory factory = new ProxyFactory();
  WrappedWorker worker = new WrappedWorker(new Worker());
  Worker wrappedWorker = factory.CreateProxy<Worker>(worker);
  
  worker.Do();
  // W rezultacie wyœwietlone zostan¹ komunikaty:
  // Przed wywo³aniem metody Do()
  // Wywo³anie metody Do()
  // Po wywo³aniu metody Do()
 }
}
\end{lstlisting}

Wiedz¹c czym jest obiekt poœrednicz¹cy, mo¿liwe jest opisanie sposobu realizacji programowania kontraktowego przez bibliotekê \emph{LinFu.Contracts}.
Zasadniczo jest to rozwiniêcie powy¿szej koncepcji.
Wewn¹trz przestrzeni nazw \emph{LinFu.DesignByContract2.Contracts} znajduje siê klasa \emph{AdHocContract}, które zdefiniowana jest jak nastêpuje:
\begin{lstlisting}[label=AdHocContract, caption=Klasa AdHocContract]
public class AdHocContract : IMethodContract, IContractProvider, ITypeContract
{
 public AdHocContract();
 public IList<IInvariant> Invariants { get; }
 public IList<IPostcondition> Postconditions { get; }
 public IList<IPrecondition> Preconditions { get; }
}
\end{lstlisting}
W jej polach przechowywane s¹ odniesienia do inwariantów, warunków pocz¹tkowych i warunków koñcowych. W po³¹czeniu z klas¹ typu \emph{ContractChecker} implementuj¹c¹ interfejs \emph{IInvokeWrapper} oraz mechanizmem tworzenia obiektów poœrednich oddawana jest funkcjonalnoœæ sprawdzania poprawnoœci kontraktów. 
\begin{lstlisting}[label=LinFuContractsEx, caption=LinFu.Contracts]
 // Obiekt, którego metody bêd¹ sprawdzane pod k¹tem poprawnoœci
 LinFuCalculator calculator = new LinFuCalculator();
 AdHocContract contract = new AdHocContract();

 ProxyFactory factory = new ProxyFactory();
 ContractChecker checker = new ContractChecker(contract);
 checker.Target = calculator;

 // Obiekt poœrednicz¹cy
 LinFuCalculator wrapped = factory.CreateProxy<LinFuCalculator>(checker);
 // Ka¿de wywo³anie metody na rzecz tego obiektu bêdzie powodowa³o 
 // sprawdzenie odpowiednich kontraktów
 wrapped.Mult(2, 3);
\end{lstlisting}

Powy¿szy fragment obrazuje sposób w jaki uaktywniany jest proces weryfikacji kontraktów, jednak w ¿aden sposób ich nie definiuje.
W tym celu, konieczne jest ich zdefiniowanie, a nastêpnie do³¹czenie ich do odpowiedniej listy zdefiniowanej w ramach klasy \emph{AdHocContract}. \\

Wszystkie rodzaje warunków definiuje siê poprzez implementacjê jednego z nastêpuj¹cych interfejsów \emph{IInvariant}, \emph{IPrecondition}, \emph{IPostcondition}. Ka¿dy z powy¿szych rozszerza interfejs \emph{IContractCheck} zdefiniowany w nastêpuj¹cy sposób:
\begin{lstlisting}
public interface IContractCheck
{
 // okreœla czy dany kontrakt powinien byæ sprawdzony w kontekœcie 
 // aktualnie wywo³ywanej metody
 bool AppliesTo(object target, InvocationInfo info);
 // Reakcja na wyj¹tek wyrzucany przez b³êdnie zdefiniowany kontrakt
 void Catch(Exception ex);
}

\end{lstlisting}
Warunki pocz¹tkowe okreœla siê poprzez utworzenie klasy implementuj¹cej interfejs \emph{IPrecondition}:
\begin{lstlisting}
public interface IPrecondition : IMethodContractCheck, IContractCheck
{
        bool Check(object target, InvocationInfo info);
        void ShowError(TextWriter output, object target, InvocationInfo info);
}
\end{lstlisting}
Metoda \emph{Check} zawiera w³aœciw¹ definicjê kontraktu, w rezultacie zwracaj¹c wartoœæ logiczn¹ mówi¹c¹ o jego spe³nieniu w kontekœcie wywo³ywanej metody.
Pobiera ona dwa argumenty, pierwszy z nich jest obiektem na rzecz którego metoda zosta³a wywo³ana, drugi z nich zawiera informacje o tym wywo³aniu, w szczególnoœci zawiera wartoœci argumentów przekazanych do metody. \\

Maj¹c te informacje mo¿liwe jest stworzenie klasy okreœlaj¹cej przyk³adowy warunek pocz¹tkowy. Niech dana bêdzie klasa \emph{Calculator} z metod¹ \emph{Div(int arg1, int arg2)}. Definicja warunku pocz¹tkowego w ramach LinFu.Contracts mog³aby mieæ nastêpuj¹c¹ postaæ: 
\begin{lstlisting}[label=LFC.Precondition, caption=Warunek pocz¹tkowy w LinFu.Contracts]
class CalculatorPrecondition : IPrecondition
{
 public bool Check(object target, LinFu.DynamicProxy.InvocationInfo info)
 {
  int argument1 = (int) info.Arguments[0];
  int argument2 = (int) info.Arguments[1];
  // warunek dla którego kontrakt nie jest spe³niony
  if (argument1 == 0 || argument2 == 0) 
   return false;
  // w pozosta³ych przypadkach warunek pocz¹tkowy uwa¿any jest za spe³niony
  return false;
 }
 
 public bool AppliesTo(object target, LinFu.DynamicProxy.InvocationInfo info)
 {
  // Okreœlenie, i¿ ten warunek ma mieæ zastosowanie 
  // tylko do klasy typu Calculator
  Calculator calculator = target as Calculator
  if (calculator == null)
   return false;
  // Sprawdzanie kontraktu ma siê odbywaæ tylko dla metody Div
  if (info.TargetMethod.Name == "Div")
   return true;
  return false;
 }
 ...
}
\end{lstlisting}

Dla przypomnienia, pokazano jak ten sam kontrakt okreœlany jest przy wykorzystaniu biblioteki \emph{AsProfiled} i \emph{Code.Contracts}
\begin{lstlisting}[label=CCvsAsP1, caption=Deklaracja kontraktu]
// AsProfiled
[AsContract("arg1 != 0 && arg2 != 0", null)]
public int Div(int arg1, int arg2)
{
 return arg1 / arg2;
}

// Code.Contracts
public int Div(int arg1, int arg2)
{
 Contract.Requires(arg1 != 0);
 Contract.Requires(arg2 != 0);
 return arg1 / arg2;
}
\end{lstlisting}

Widoczna jest tu znaczna ró¿nica w ³atwoœci definiowania kontraktu oraz 
iloœci kodu potrzebnego do uzyskania tego samego efektu. \\

Analogiczna sytuacja wystêpuje dla warunków koñcowych. Ponownie, konieczne jest zdefiniowanie klasy implementuj¹cej tym razem interfejs \emph{IPostcondition}, który ró¿ni siê od \emph{IPrecondition} metod¹ \emph{BeforeMethodCall} oraz zmienion¹ sygnatur¹ metody \emph{Check}.
\begin{lstlisting}[label=BeforeMethodCall, caption=Deklaracja BeforeMethodCall]
void BeforeMethodCall(object target, InvocationInfo info);
bool Check(object target, InvocationInfo info, object returnValue);
\end{lstlisting}

Metoda \emph{Check} posiada dodatkowy argument \emph{returnValue}, który oznacza wartoœæ zwracan¹ metody (odpowiednik @returnValue z \emph{AsProfiled} oraz Contract.OldValue z \emph{CodeContracts}).\\

Metoda \emph{BeforeMethodCall} zosta³a dodana w celu obs³ugi wartoœci pocz¹tkowych argumentów i wykonywana jest przed wejœciem do metody docelowej.
W tym rozwi¹zaniu mo¿na dostrzec pewn¹ analogiê z podejœciem u¿ytym w \emph{AsProfiled}. Tam te¿ dokonywane jest przetwarzanie wstêpne przed wejœciem do metody, w³aœnie w celu przechowania stanu parametrów u¿ytych w kontrakcie.
W przeciwieñstwie jednak do niej, tu za poprawne zachowanie ich wartoœci odpowiedzialny jest twórca kontraktu. W \emph{AsProfiled} i \emph{CodeContracts} czynnoœæ ta przerzucona zosta³a na bibliotekê i zachodzi ca³kowicie bez wiedzy osoby nak³adaj¹cej wiêzy poprawnoœci na metodê. \\

Maj¹c wiedzê na temat definiowania warunków koñcowych, mo¿liwe jest porównanie  ich wykorzystania w stosunku do tego co zosta³o pokazane przyk³adzie \ref{lst:AsContract}.

\begin{lstlisting}[label=AccountClass, caption=Klasa Account]
public class Account
{
 public int Balance;
 public virtual void Deposit(int amount)
 {
  this.Balance += amount;
 }
}
\end{lstlisting}

\begin{lstlisting}[label=AccountPC, caption=Definicja warunku koñcowego]
class AccountPC : IPostcondition
{
 private int oldBalance;
 public void BeforeMethodCall(object target, InvocationInfo info)
 {
  oldBalance = (target as Account).Balance;
 }

 public bool Check(object target, InvocationInfo info, object returnValue)
 {
  Account account = target as Account;
  return account.Balance == oldBalance + (int)info.Arguments[0];
 }

 public bool AppliesTo(object target, InvocationInfo info)
 {
  if (target as Account == null)
   return false;
  if (info.TargetMethod.Name == "Deposit")
   return true;
  return false;
}
\end{lstlisting}

Warunek zawiera sprawdzenie bilans rachunku po wp³yniêciu depozytu jest równy jego wartoœci pocz¹tkowej powiêkszonej o zadan¹ wartoœæ. \\

Podsumowuj¹c, biblioteka LinFu.Contracts spe³nia wszystkie funkcjonalnoœci niezbêdne do programowania kontraktowego. Z drugiej strony mo¿na podejrzewaæ, i¿ nie by³o to g³ównym za³o¿eniem podczas projektowania LinFu. Definiowanie kontraktów wymaga dosyæ du¿ego nak³adu pracy w porównaniu do prezentowanych wczeœniej rozwi¹zañ. \\

Do zalet tego rozwi¹zania mo¿na zaliczyæ nieinwazyjnoœæ definicji kontraktów w stosunku do sprawdzanego kodu. Zestaw kontraktów mo¿e byæ zawarty w osobnej bibliotece, za³¹czanej w zale¿noœci od potrzeby. Z drugiej strony, wymóg konstruowania obiektów przy u¿yciu metod fabrykuj¹cych mo¿e okazaæ siê niemo¿liwy do spe³nienia w przypadku ju¿ istniej¹cego kodu, gdy¿ wi¹za³o by siê to z du¿ym nak³adem pracy. Dodatkowo, u¿ycie LinFu.Contracts wymusza definiowanie klas jako publicznych, zaœ metody które maj¹ byæ przes³oniête musz¹ byæ oznaczone jako wirtualne - wynika to ze specyfiki koncepcji tworzenia dynamicznych obiektów poœrednicz¹cych.

\section{Porównanie funkcjonalnoœci opisywanych bibliotek}
W tym miejscu prezentowane jest podsumowanie funkcjonalnoœci przedstawionych bibliotek.

\begin{longtable}{ | l | p{3cm} | p{3cm} | p{3cm} |} \hline
Cecha & AsProfiled & CodeContracts & LinFuContracts \\ \hline

Okreœlenie kontraktu &
\tiny Atrybut nak³adany na metodê &
\tiny Wewn¹trz metody przy u¿yciu metod z biblioteki &
\tiny Osobna klasa implementuj¹ca odpowiednie interfejsy \\ \hline

U¿yte podejœcie &
\tiny Zewnêtrzna biblioteka \newline
\tiny Odbieranie powiadomieñ od maszyny CLR \newline
\tiny Interpretacja danych binarnych  \newline &

\tiny Przepisywanie jêzyka poœredniego skompilowanego programu &

\tiny Dynamiczna generacja obiektu poœrednicz¹cego \\ \hline

Warunki pocz¹tkowe &
\checkmark &

\checkmark \newline 
\tiny (Contract.Requires) &

\checkmark \newline 
\tiny (interfejs IPrecondition) \\ \hline

Warunki koñcowe &
\checkmark &

\checkmark \newline
\tiny (Contract.Ensures) &

\checkmark \newline
\tiny (interfejs IPostcondition) \\ \hline

Wartoœci pocz¹tkowe &
\checkmark \newline
\tiny (\textasciicircum identyfikator) &

\checkmark \newline
\tiny (Contract.Old) &

\checkmark \newline
\tiny (metoda BeforeMethodCall, wymaga rêcznej implementacji) \\ \hline

Wartoœæ zwracana &
\checkmark \newline
\tiny (@returnValue) &

\checkmark \newline
\tiny (Contract.Result) &

\checkmark \newline
\tiny (parametr returnValue) \\ \hline

Inwariant klasy &

- \newline
\tiny (³atwa implementacja, wystarczy sprawdzaæ kontrakt dla klasy w momencie wywo³ania i zakoñczenia metody) &

\checkmark \newline
\tiny (metoda oznaczona atrybutem [ContractInvariantMethod]) &

\checkmark \newline
\tiny (interfejs IInvariant) \\ \hline

\end{longtable}









