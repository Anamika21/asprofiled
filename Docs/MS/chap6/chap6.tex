\chapter{Porównanie z innymi bibliotekami}
W tej czêœci opisano dwa rozwi¹zania realizuj¹ce podejœcie programowania kontraktowego. Podobnie jak biblioteka AsProfiled s¹ one przeznaczone dla programów pracuj¹cych w ramach platformy .NET.

\section{CodeContracts}
Jest to kompleksowe rozwi¹zanie firmy Microsoft, pocz¹tkowe tworzone w ramach komórki badawczej Mirosoft Research. Obecnie jest ju¿ dostêpna na rynku w pe³ni funkcjonalna wersja tego zestawu narzêdzi i wchodz¹ one w sk³ad œrodowiska programistycznego Visual Studio 2010. \\

Z perspektywy implementacyjnej w ramach \emph{Code Contracts} zastosowano zgo³a inne podejœcie, od tego, które reprezentowane jest przez AsProfiled.
Dla przypomnienia, AsProfiled stanowi zewnêtrzn¹ bibliotekê, do której odwo³ania wystêpuj¹ na poziomie maszyny wirtualnej .NET. Sprawdzany program nie ma œwiadomoœci istnienia tej biblioteki, a jedynym elementem zewnêtrznym jest klasa definiuj¹ca atrybuty, poprzez który reprezentowany jest kontrakt.
W przypadku u¿ycia \emph{Code Contracts}, kontrolowany program (biblioteka) odwo³uje siê bezpoœrednio do metod zdefiniowanych w ramach przestrzeni nazw \emph{System.Diagnostics.Contracts}. 

Razem z bibliotek¹ dostarczane jest narzêdzie \emph{ccrewrite.exe}, które jest kluczowym elementem w zadaniu sprawdzania poprawnoœci kontraktów w czasie dzia³ania aplikacji. Narzêdzie to, dostaj¹c na wejœciu skompilowan¹ bibliotekê,
odnajduje wszelkie odwo³ania do metod zawartych w przestrzeni nazw \emph{System.Diagnostics.Contracts}, a nastêpnie modyfikuje jej kod poœredni.
Transformacja ta polega na zamianie wszystkich odwo³añ do definicji kontraktów, na odpowiadaj¹ce im bloki kodu. Na przyk³ad, odwo³ania do wartoœci pocz¹tkowych 
bêd¹ przet³umaczone na ci¹g operacji w wyniku których zostan¹ one skopiowane i zachowane, dziêki czemu bêd¹ mog³y byæ u¿yte w warunku koñcowym.

Przepisywanie kodu skompilowanej biblioteki przy u¿yciu powy¿szego narzêdzia to g³ówna i zasadnicza ró¿nica w podejœciu w stosunku do tego co zosta³o wykorzystane w \emph{AsProfiled}. \\

 
Narzêdzie \emph{Ccrewrite.exe} poprzez przepisywanie kodu umo¿liwia umieszczenie wszystkich deklaracji kontraktów na pocz¹tku metody.
Zmodyfikowany kod bêdzie zawiera³ sprawdzenie kontraktu koñcowego we wszystkich miejscach, w których mo¿liwe jest opuszczenie metody.  \\

Z punktu widzenia u¿ytkownika, zasadnicza ró¿nic¹, w stosunku do biblioteki AsProfiled jest sposób okreœlania kontraktów.
W tym wypadku s¹ one definiowane jako wywo³ania statycznych metod klasy \emph{Contract}, przy czym kontrakt podawany jako ich argument, w postaci wyra¿enia logicznego. Poprawnym wyra¿eniem jest dowolne wyra¿enie zgodne z regu³ami ich budowania w ramach ustalonego jêzyka programowania.
Podejœcie to ma zasadnicz¹ zaletê, mianowicie kontrakty s¹ silnie typowane.
Poni¿szy wycinek kodu ilustruje dotychczasowy opis:

\begin{lstlisting}[label=lst:CodeContracts1, caption=CodeContracts - sposób u¿ycia]

public int Test(int arg1, int arg2)
{
 Contract.Requires(PreCondition);
 Contract.Ensures(PostCondition);
 int result = arg1 * arg2;
 return result;
}
\end{lstlisting}

Przy pomocy metod \emph{Requires} i \emph{Ensure} okreœlane s¹ odpowiednio warunki pocz¹tkowe i warunki koñcowe. Ich argumentem mo¿e byæ dowolnie skomplikowane wyra¿enie obliczalne do wartoœci logicznej, a ka¿da z tych metod mo¿e byæ wywo³ana dowoln¹ liczbê razy.

Dla porównania, poni¿ej zestawiono deklaracje tego samego kontraktu pocz¹tkowego w ramach bibliotek.
\emph{Code.Contracts} i \emph{AsProfiled}:

\begin{lstlisting}[label=CCvsAsP1, caption=Deklaracja kontraktu]
// AsProfiled
[AsContract("arg1 != 0 && arg2 != 0", "@returnValue != 0")]
public int Div(int arg1, int arg2)
{
 return arg1 / arg2;
}

// Code.Contracts
public int Div(int arg1, int arg2)
{
 Contract.Requires(arg1 != 0);
 Contract.Requires(arg2 != 0);
 Contract.Ensures(Contract.Result<int>() != 0);
 return arg1 / arg2;
}
\end{lstlisting}

W tym przyk³adnie, poza wczeœniej wymienionymi metodami \emph{Requires} i \emph{Ensures}, znajduje siê wywo³anie metody \emph{Contract.Results \textless int\textgreater()}.
Jest to odpowiednik elementu \emph{@returnValue} w obrêbie kontraktów AsContracts, a wiêc oznacza odwo³anie do wartoœci zwracanej z metody.\\

Kolejn¹ wspóln¹ cech¹ bibliotek \emph{Code Contracts} oraz \emph{AsProfiled} jest mo¿liwoœæ odwo³ywania siê do wartoœci pocz¹tkowych argumentów metody.
W ramach kontraktów \emph{AsContracts} odwo³anie do wartoœci pocz¹tkowych oznaczane s¹ przez \emph{\^{}nazwaArgumentu}, z kolei tutaj t¹ rolê pe³ni metoda 
\emph{Contracts.OldValue\textless T \textgreater(T value)}.
Za zachowywanie tych wartoœci odpowiedzialny jest kod wygenerowany przez \emph{ccrewrite.exe}. 
Poni¿szy kod ilustruje wykorzystanie tej funkcjonalnoœci.

\begin{lstlisting}[label=CodeContracts2, caption=Wykorzystanie wartoœci pocz¹tkowych]
public void Deposit(Account account, int amount)
{
 Contract.Requires(amount > 0);
 Contract.Ensures(account.Balance == Contract.OldValue(account.Balance) + amount); 
 account.Balance += amount;
}
\end{lstlisting}

Odpowiednik powy¿szego kontraktu w ramach biblioteki AsProfiled jest nastêpuj¹cy:
\begin{lstlisting}[label=CCvsAS2, caption=Warunki pocz¹tkowe w AsContract]
[AsContract("amount > 0", "^account.Balance + amount == account.Balance")]
public void Deposit(Account account, int amount)
{
 account.Balance += amount;
}
\end{lstlisting} 

Dodatkowo \emph{Code Contracts} udostêpnia kilka innych, u¿ytecznych funcjoalnoœci, których nie posiada biblioteka \emph{AsProfiled}. S¹ to miêdzy innymi:
\begin{enumerate}
\item Contract.Requires\textless TException\textgreater( bool condition ) - w przypadku, niespe³nienia kontraktu, rzucany jest wyj¹tek okreœlonego typu
\item Contract.EnsuresOnThrow\textless TException\textgreater( bool condition ) - okreœla warunek koñcowy jaki musi byæ zachowany w przypadku wyst¹pienia wyj¹tku typu TException
\item Deklaracja niezmiennków, czyli warunków nak³adanych na obiekt, które s¹ sprawdzane przed i po wywo³aniu ka¿dej z publicznych metod obiektu.

\begin{lstlisting}[label=CodeContracts3, caption=Niezmiennik obiektu]
[ContractInvariantMethod]
private void ObjectInvariant () 
{
 Contract.Invariant ( condition1 );
 Contract.Invariant ( condition2 );
}
\end{lstlisting}
Metoda oznaczona atrybutem \emph{[ContractInvariantMehtod]} jest wywo³ywana przez odpowiedni kod wygenerowany przez narzêdzie \emph{ccrewrite.exe} 
\end{enumerate}

Podsumowuj¹c, \emph{Code Contracts} w obecnej postaci jest dopracowanym rozwi¹zaniem, o czym œwiadczy fakt, i¿ jest czêœci¹ oficjalnej dystrybucji platformy .NET 4.0. Du¿¹ zalet¹ w stosunku do biblioteki AsProfiled, poza bogatsz¹ funkcjonalnoœci¹, jest silne typowanie wyra¿eñ okreœlaj¹cych warunki. U³atwia to ich pisanie oraz uniemo¿liwia tworzenie niepoprawnych w sensie sk³adniowym warunków. 

\section{LinFu.Contracts}
LinFu.Contracts wchodzi w sk³ad bibliotek zgrupowanych w ramach projektu LinFu, stworzonego przez Philipa Laureano a udostêpnianego na zasadach wolnego oprogramowania. U podstaw tej biblioteki le¿y mechanizm generowania dynamicznych obiektów poœrednicz¹cych (eng. \emph{dynamic proxy}), które pozwalaj¹ na przechwytywanie wywo³añ metod na docelowym obiekcie. 
Ten w³aœnie mechanizm wykorzystywany jest przy realizacji podejœcia programowania kontraktowego. \\
Proces tworzenia obiektu poœrednicz¹cego odbywa siê poprzez metodê \emph{CreateProxy\textless T\textgreater(IInvokeWrapper wrapper)} nale¿¹cej do klasy \emph{ProxyFactory}. W rezultacie zwracany jest uchwyt to obiektu typu \emph{T}, przy czym ka¿de odwo³anie do jego metod bêdzie przechwytywane przez obiekt implementuj¹cy interfejs \emph{IInvokeWrapper}.
Interfejs ten okreœlony jest w sposób nastêpuj¹cy:

\begin{lstlisting}[label=IInvokeWrapper, caption=Interfejs IInvokeWrapper]
public interface IInvokeWrapper
{
 void BeforeInvoke(InvocationInfo info);
 object DoInvoke(InvocationInfo info);
 void AfterInvoke(InvocationInfo info, object returnValue);
}
\end{lstlisting}
Powy¿sze metody wywo³ywane s¹ przez obiekt poœrednicz¹cy w momentach zgodnych z ich nazewnictwem, tzn. \emph{BeforeInvoke}, \emph{AfterInvoke} oznaczaj¹ moment przed i po wywo³aniu, natomiast \emph{DoInvoke} to w³aœciwe wywo³anie. Nale¿y zaznaczyæ i¿ metoda na obiekcie docelowym mo¿e, ale nie musi byæ wykonana, decyduje o tym implementacja metody \emph{DoInvoke}. 
Dla jasnoœci prezentowany jest poni¿szy przyk³ad:
\begin{lstlisting}[label=DynamicProxy, caption=Tworzenie obiektu poœredniego]
// Klasa pocz¹tkowa 
public class Worker 
{
 public virtual void Do() 
 {
  Console.WriteLine("Metoda Do()");
 }
}

public class WrappedWorker : IInvokeWrapper 
{
 object _target;
 public WrappedWorker(object target)
 {
  _target = target;
 }
 void BeforeInvoke(InvocationInfo info) 
 {
  Console.WriteLine("Przed wywo³aniem metody Do()");
 }

 object DoInvoke(InvocationInfo info)
 {
  Console.WriteLine("Wywo³anie metody Do()");
  object result = null;
  // W celu wywo³ania oryginalnej metody Do() nale¿y 
  // usun¹æ komentarz z nastêpnej linii:
  // result = info.TargetMethod.Invoke(_target, info.Arguments);
  return result;
 }

 void AfterInvoke(InvocationInfo info, object returnValue) 
 {
    Console.WriteLine("Po wywo³aniu metody Do()");
 }
}

public class Program 
{
 public static void Main(string[] args)
 {
  ProxyFactory factory = new ProxyFactory();
  WrappedWorker worker = new WrappedWorker(new Worker());
  Worker wrappedWorker = factory.CreateProxy<Worker>(worker);
  
  worker.Do();
  // W rezultacie wyœwietlone zostan¹ komunikaty:
  // Przed wywo³aniem metody Do()
  // Wywo³anie metody Do()
  // Po wywo³aniu metody Do()
 }
}
\end{lstlisting}

Teraz ju¿, wiedz¹c czym jest obiekt poœrednicz¹cy, mo¿liwe jest opisanie sposobu realizacji programowania kontraktowego przez bibliotekê \emph{LinFu.Contracts}.
Zasadniczo jest to rozwiniêcie powy¿szej koncepcji.
Wewn¹trz przestrzeni nazw \emph{LinFu.DesignByContract2.Contracts} znajduje siê klasa \emph{AdHocContract}, które zdefiniowana jest jak nastêpuje:
\begin{lstlisting}[label=AdHocContract, caption=Klasa AdHocContract]
public class AdHocContract : IMethodContract, IContractProvider, ITypeContract
{
 public AdHocContract();
 public IList<IInvariant> Invariants { get; }
 public IList<IPostcondition> Postconditions { get; }
 public IList<IPrecondition> Preconditions { get; }
}
\end{lstlisting}
W jej polach przechowywane s¹ odniesienia do inwariantów, warunków pocz¹tkowych i warunków koñcowych. W po³¹czeniu z klas¹ typu \emph{ContractChecker} implementuj¹c¹ interfejs \emph{IInvokeWrapper} oraz mechanizmem tworzenia obiektów poœrednich oddawana jest funkcjonalnoœæ sprawdzania poprawnoœci kontraktów. 
\begin{lstlisting}[label=LinFuContractsEx, caption=LinFu.Contracts]
 // Obiekt, którego metody bêd¹ sprawdzane pod k¹tem poprawnoœci
 LinFuCalculator calculator = new LinFuCalculator();
 AdHocContract contract = new AdHocContract();

 ProxyFactory factory = new ProxyFactory();
 ContractChecker checker = new ContractChecker(contract);
 checker.Target = calculator;

 // Obiekt poœrednicz¹cy
 LinFuCalculator wrapped = factory.CreateProxy<LinFuCalculator>(checker);
 // Ka¿de wywo³anie metody na rzecz tego obiektu bêdzie powodowa³o 
 // sprawdzenie odpowiednich kontraktów
 wrapped.Mult(2, 3);
\end{lstlisting}

Powy¿szy fragment obrazuje sposób w jaki uaktywniany jest proces weryfikacji kontraktów, jednak w ¿aden sposób ich nie definiuje.
W tym celu, konieczne jest ich zdefiniowanie, a nastêpnie do³¹czenie ich do odpowiedniej listy zdefiniowanej w ramach klasy \emph{AdHocContract}. \\

Wszystkie rodzaje warunków definiuje siê poprzez implementacjê jednego z nastêpuj¹cych interfejsów \emph{IInvariant}, \emph{IPrecondition}, \emph{IPostcondition}. Wszystkie one rozszerzaj¹ interfejs \emph{IContractCheck} zdefiniowany w nastêpuj¹cy sposób:
\begin{lstlisting}
public interface IContractCheck
{
 // okreœla czy dany kontrakt powinien byæ sprawdzony w kontekœcie 
 // aktualnie wywo³ywanej metody
 bool AppliesTo(object target, InvocationInfo info);
 // Reakcja na wyj¹tek wyrzucany przez b³êdnie zdefiniowany kontrakt
 void Catch(Exception ex);
}

\end{lstlisting}
Warunki pocz¹tkowe okreœla siê poprzez utworzenie klasy implementuj¹cej interfejs \emph{IPrecondition}:
\begin{lstlisting}
public interface IPrecondition : IMethodContractCheck, IContractCheck
{
        bool Check(object target, InvocationInfo info);
        void ShowError(TextWriter output, object target, InvocationInfo info);
}
\end{lstlisting}



