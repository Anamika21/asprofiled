%*********** Rodzia³ 3 ************
\chapter{Omówienie funkcjonalnoœci biblioteki}
\section{Ogólny schemat architektury biblioteki AsProfiled}
Poni¿ej przedstawiony jest ogólny schemat dzia³ania biblioteki AsProfiled.
\begin{figure}[h]
\centering
\includegraphics[width=5in]{generalflow}
\caption{Schemat dzia³ania aplikacji}
\label{fig:generalFlowDiagram}
\end{figure}
\clearpage
Na rysunku \ref{fig:generalFlowDiagram} wyszczególniono kolejne kroki w procesie weryfikacji kontraktów. 
Biblioteka \emph{AsProfiled} zaczyna swoje dzia³anie w momencie uruchomienia programu na maszynie wirtualnej .NET w odpowiednio przygotowanym œrodowisku. Œrodowisko uruchomieniowe CLR ³aduje bibliotekê do pamiêci, po czym nastêpuje proces inicjalizacji biblioteki. Uruchamianie poszczególnych funkcji biblioteki jest konsekwencj¹ odebrania jednego ze zdarzeñ zachodz¹cych wewn¹trz programu, którego poprawnoœæ jest sprawdzana. Biblioteka obs³uguje nastêpuj¹ce zdarzenia:
\begin{enumerate}
\item Rozpoczêcie wykonywania metody.
\item Zakoñczenie wykonywania metody.
\item Zakoñczenie wykonywania programu.
\end{enumerate}
Reakcj¹ na pierwsze dwa zdarzenia jest ewaluacja kontraktu metody, jeœli takowy zosta³ dla niej zdefiniowany. Cykl ten trwa do momentu, w którym badany program koñczy dzia³anie lub w przypadku, gdy któryœ z warunków pocz¹tkowych lub koñcowych nie zosta³ spe³niony.

\section{Przyk³ad wykorzystania biblioteki AsProfiled}
W przyk³adzie \ref{lst:AccountTest} na³o¿ono kontrakt, wyra¿ony przy pomocy atrybutu \emph{AsContract}, na metodê \emph{Transfer}.
Okreœla on warunek pocz¹tkowy, nak³adaj¹cy wiêzy na dane wejœciowe metody i oznacza tyle, ¿e kwota przelewu nie mo¿e byæ wiêksza ni¿ stan konta Ÿród³owego.
Warunek koñcowy, zdefiniowany przy pomocy drugiego argumentu atrybutu, mówi i¿ metoda powinna zwróciæ wyniki \emph{true}, oznaczaj¹cy poprawne zakoñczenie operacji i suma pocz¹tkowych stanów kont jest równa ich sumie po zakoñczeniu wykonywania metody. \\

Niech dany bêdzie kod wykonuj¹cy t¹ metodê.
\begin{lstlisting}[label=TestRun, caption=Wykonanie przelewu]
Account acc1 = new Account();
acc1.Balance = 500;
Account acc2 = new Account();
acc2.Balance = 300;
AccountManager manager = new AccountManager();
manager.Transfer(acc1, acc2, 100);
\end{lstlisting}

Nie jest trudno sprawdziæ, ¿e w tym wypadku kontrakt jest spe³niony. Potwierdza to uruchomienie tego przyk³adu z w³¹czon¹ opcj¹ weryfikacji kontraktów przez \emph{AsProfiled}. Dla tego przypadku wynik jej dzia³ania jest nastêpuj¹cy:

\lstset{
morecomment=[n][\textbf]{TRUE}
}
\begin{lstlisting}[label=lst:AsProfiledOutput, caption=Wynik dzia³ania AsProfiled]
TestApplication.Calculator.AccountManager.Transfer
source.Balance > amount
Program
 Cmp Exp
  Value
   Identifier:source.Balance
  Cmp Operator
   >:>
  Value
   Identifier:amount

Precondition:TRUE

TestApplication.Calculator.AccountManager.Transfer
@returnValue == true && ^source.Balance + 
 ^destination.Balance == source.Balance + destination.Balance
Program
 Boolean Exp
  Cmp Exp
   Value
    ReturnValue:@returnValue
   Cmp Operator
    ==:==
   Value
    BooleanLiteral:true
  Boolean Operator
   &&:&&
  Cmp Exp
   Add Exp
    Value
     InitialValue:^source.Balance
    Add Operator
     +:+
    Value
     InitialValue:^destination.Balance
   Cmp Operator
    ==:==
   Add Exp
    Value
     Identifier:source.Balance
    Add Operator
     +:+
    Value
     Identifier:destination.Balance

Postcondition:TRUE
\end{lstlisting}
Oczywiœcie, s¹ to g³ównie komunikaty diagnostyczne. Ukazuj¹ one jednak cykl pracy aplikacji. Wypisywane s¹ nazwy metod z przypisanym atrybutem \emph{AsContract},
odczytywane jest wyra¿enie opisuj¹ce warunek pocz¹tkowy lub koñcowy, z którego   tworzone jest drzewo rozbioru. W koñcu nastêpuje jego ewaluacja i wypisanie wartoœci oznaczaj¹cej czy kontrakt zosta³ spe³niony czy te¿ nie. Naturalnie, jeœli któryœ z warunków nie by³by spe³niony to zgodnie z zasad¹ programowania kontraktowego nastêpuje przerwanie wykonywania dalszych instrukcji programu.
Jak widaæ na listingu \ref{lst:AsProfiledOutput} zarówno warunek
wejœcia jak i warunek wyjœcia by³y spe³nione w momencie ich
ewaluacji. \\

%Tak pogl¹dowo przedstawia siê sposób dzia³ania biblioteki \emph{AsProfiled}. W %dalszej czêœci poszczególne elementy zosta³y opisane w szczegó³owy sposób.


\section{Inspekcja nadzorowanego programu}

W obrêbie œrodowiska Microsoft .NET jedyny sposób rozszerzenia mechanizmu profilowania o w³asn¹ funkcjonalnoœæ polega na zaimplementowania odpowiednich interfejsów profilera. Dodatkowo, biblioteka implementuj¹ca te interfejsy musi byæ utworzona w technologii COM (ang. \textbf C\textnormal omponent \textbf O\textnormal bject \textbf M\textnormal odel) \cite{website:com}. Jest to standard definiowania i tworzenia interfejsów programistycznych na poziomie binarnym, niezale¿nym od konkretnego jêzyka programowania, dla komponentów oprogramowania wprowadzony przez firmê Microsoft. Obecnie czynione s¹ starania, aby odejœæ od tego standardu, w³aœnie poprzez upowszechnianie platformy .NET. Z drugiej strony, czêœæ platformy ma postaæ bibliotek COM, wiêc ca³kowita rezygnacja z tego rozwi¹zania nie jest na t¹ chwilê mo¿liwa. \\
%Podczas budowy biblioteki COM, implementuja;cej interfejsy profiluja;ce %konieczne jest pos?ugiwania sie; je;zykiem C++, gdyz. funkcjonalnos'ci %biblioteki wywo?ywane sa; przez s'rodowisko uruchomieniowe w newralgicznych %momentach wykonywania, w czasie których   ta jest wywo?ywana   

%Jednym z wymagañ, które s¹ stawiane ka¿dej bibliotece typu COM jest implementacja interfejsu bazowego \emph{IUnknown}, dziêki któremu mo¿liwe jest uzyskanie uchwytów do pozosta³ych interfejsów implementowanych w ramach tej biblioteki. 
%Jêzyk C++, który zosta³ wykorzystany do utworzenia biblioteki AsProfiled, wspiera programowanie poprzez klasy czysto wirtualne, a ich implementacja przebiega w sposób standardowy.
% Drug¹ konsekwencj¹ tego jest koniecznoœæ rejestracji takiej biblioteki w systemie.
%Do tego celu u¿ywana jest aplikacja o nazwie regsrv32.exe, która to jest jednym z narzêdzi dostarczanych wraz z platform¹ .NET.
%Pobiera ona identyfikator biblioteki, którym jest wartoœæ typu GUID, a nastêpnie  umieszcza w rejestrze systemu klucz sk³adaj¹cy siê z tego identyfikatora i œcie¿ki w systemie plików, okreœlaj¹cej po³o¿enie biblioteki.\\

Rozpoczêcie procesu profilowania/weryfikacji aplikacji odbywa siê poprzez uruchomienie programu z linii poleceñ w odpowiednio przygotowanym œrodowisku.
Etap ten polega na ustawieniu zmiennych œrodowiskowych, instruuj¹cych maszynê wirtualn¹ CLR, aby u¿ywa³a wskazanego obiektu implementuj¹cego interfejs
profilera, przekazuj¹c do niego powiadomienia na temat zdarzeñ zachodz¹cych wewn¹trz uruchamianej aplikacji. 
Zmienne, których wartoœci nale¿y ustawiæ to \emph{COR\_ENABLE\_PROFILING} oraz \emph{COR\_PROFILER}. Mo¿na to zrobiæ, na przyk³ad, poprzez u¿ycie podanego skryptu pow³oki:
\begin{lstlisting}[label=lst:initProfiling, caption=Inicjalizacja œrodowiska]
SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={GUID}
\end{lstlisting} 

Identyfikator GUID jest wykorzystywany do okreœlenia lokalizacji biblioteki. \\

Liczba i rodzaj wysy³anych powiadomieñ okreœlany jest wewn¹trz biblioteki profiluj¹cej. W szczegó³ach temat ten opisany jest w kolejnym rozdziale.

\section{Kontrakty}
Podstawowym elementem, dziêki któremu mo¿liwa jest weryfikacja metod, jest  mo¿liwoœæ definiowania kontraktu. Zgodnie z tym co zosta³o powiedziane kontrakty definiujemy za pomoc¹ atrybutów. \\

Atrybuty s¹ to znaczniki o charakterze deklaracyjnym zawieraj¹ce
informacjê o elementach programu (np. klasach, typach wyliczeniowych, metodach) przeznaczon¹ do wykorzystania w trakcie dzia³ania programu.
W tym kontekœcie istotne jest to, i¿ s¹ one pamiêtane jako meta dane danego elementu programu.
Definicja atrybutów jest jedynym elementem, wchodz¹cym bezpoœrednio w sk³ad omawianego rozwi¹zania, który musi znajdowaæ siê po stronie weryfikowanej aplikacji. \\

Atrybuty okreœlaj¹ce kontrakt maj¹ postaæ: 
\begin{lstlisting}[label=AsContract, caption=Ogólna postaæ kontraktu]
AsContract(Warunek pocz¹tkowy, Warunek koñcowy)
\end{lstlisting}
Oba warunki zdefiniowane s¹ poprzez pewne, okreœlone przez u¿ytkownika wyra¿enie. Te z kolei maj¹ postaæ okreœlon¹ przez zadan¹ gramatykê, której definicjê przedstawiono w nastêpnym rozdziale dotycz¹cym implementacji.
Warunki kontraktu definiowane s¹ w ramach ³añcuchów znakowych. Poci¹ga to za sob¹ koniecznoœæ przeprowadzenia analizy sk³adniowej, której wynikiem jest
drzewo rozbioru wyra¿eñ. W rezultacie jego ewaluacji otrzymywana jest wartoœæ okreœlaj¹ca czy udekorowana metoda spe³nia na³o¿ony na ni¹ kontrakt w kontekœcie danego wywo³ania.


\section{Funkcjonalnoœci biblioteki}

W dalszych rozwa¿aniach oparto siê na definicji klas \emph{Account} oraz \emph{AccountManager} z przyk³adu \ref{lst:AccountTest} rozszerzonej o nastêpuj¹ce metody:

\begin{lstlisting}[label=lst:AccountManagerClass, caption=Klasa AccountManager]
class AccountManager {

 
 [AsContract(null, "@returnValue.OwnerName == newName")]
 public Account ChangeOwnerName(Account account, string newName) 
 {
  // Wywo³anie metody rejestruj¹cej bie¿¹c¹ operacjê w bazie danych
  // Zwraca zapisan¹ wartoœæ
  account.OwnerName = Database.SetAccountOwnerInternal(account.accountId, newName);
  return account; 
 }

 
 [AsContract(null, "account.Balance == ^account.Balance + sum")]
 public Account Deposit(Account account, int sum) 
{
  // Wywo³anie metody zapisuj¹cej do bazy danych nowy stan konta o danym
  // identyfikatorze
  // Zwraca uaktualniony obiekt typu Account
  int newBalance = Database.DepositInternal(AccountId, sum);
  account.Balance = newBalance;
  return account; 
 }
}
\end{lstlisting}

Metoda \emph{ChangeOwnerName} dokonuje zamiany w³aœciciela konta, którego obiekt przekazywany jest jako parametr.
Metoda \emph{Deposit} deponuje okreœlon¹ kwotê na danym koncie. 
\subsection{Odczytywanie wartoœci argumentów metod}

Dziêki informacjom zawartym w metadanych, mo¿liwe jest okreœlenie liczby i typów parametrów przekazywanych do metod. S¹ to dane statyczne, w tym sensie, ¿e s¹ one sta³e w ramach raz zdefiniowanego programu. Z drugiej strony, wartoœci parametrów mog¹ byæ inne dla ka¿dego wywo³ania metody, tak wiêc nie mog¹ w ¿aden sposób stanowiæ czêœci metadanych. Musi wiêc istnieæ inny mechanizm pozwalaj¹cy na odczyt wartoœci argumentów. Okazuje siê, ze maszyna CLR wraz w powiadomieniem o rozpoczêciu wykonywania metody dostarcza strukturê wewn¹trz której znajduj¹ siê odniesienia do fragmentów pamiêci, gdzie zapisane s¹ aktualne wartoœci argumentów. S¹ to dane binarne, które nale¿y interpretowaæ zgodnie z typem argumentu, które reprezentuj¹. Biblioteka \emph{AsProfiled} umo¿liwia odczyt wartoœci pól znajduj¹cych siê w dowolnym miejscu w hierarchii w ramach przekazywanego parametru. Warunek koñcowy na³o¿ony na metodê \emph{Deposit} w ramach klasy z przyk³adu \ref{lst:AccountManagerClass} ilustruje odwo³anie siê do wewnêtrznych pól przekazywanego parametru.


\subsection{Wartoœci zwracane}
\label{sec:chapter4:section5}

Kolejnym elementem jest mo¿liwoœæ weryfikacji kontraktów zawieraj¹cych w sobie odniesienia do wartoœci zwracanej przez metodê.\\


Metoda \emph{ChangeOwnerName} z przyk³adu \ref{lst:AccountManagerClass} zwraca obiekt typu \emph{Account}, z uaktualnion¹ wartoœci¹ \emph{OwnerName} mówi¹c¹ o dostêpnych œrodkach. W celu sprawdzenia poprawnoœci dzia³ania tej funkcjonalnoœci mo¿liwe jest na³o¿enie odpowiedniego kontraktu  na metodê \emph{ChangeOwnerName}. Przy u¿yciu atrybutów z biblioteki \emph{AsProfiled} mo¿liwa jest inspekcja wartoœci obiektu zwracanego z metody. Takie odniesienia maj¹ tylko sens przy warunkach koñcowych, po odebraniu notyfikacji o zdarzeniu opuszczenia metody.
W ramach atrybutów \emph{AsContract} odwo³anie do wartoœci zwracanej odbywa siê poprzez u¿ycie  identyfikatora \emph{@returnValue}. \\
Sposób odczytu wartoœci zwracanej jest analogiczny do odczytywania wartoœci parametrów metody. Szczegó³y techniczne opisuj¹ce ten proces zosta³y podane w nastêpnym rozdziale.

\subsection{Wartoœci pocz¹tkowe}

Termin wartoœci pocz¹tkowe odnosi siê do stanu argumentów w momencie wywo³ania metody. Zgodnie z za³o¿eniami z rozdzia³u pierwszego, biblioteka powinna udostêpniaæ funkcjonalnoœæ definiowania kontraktów z³o¿onych z odwo³añ do pocz¹tkowych wartoœci obiektów. Naturalnie, stan obiektów mo¿e ulec zmianie w czasie dzia³ania metody, nale¿a³o wiêc przedsiêwzi¹æ kroki umo¿liwiaj¹ce tego rodzaju odwo³ania do pocz¹tkowych wartoœci obiektów. 

Jedyn¹ sytuacj¹ jak¹ nale¿y rozwa¿yæ jest przypadek, w którym odwo³ania do wartoœci pocz¹tkowych ma miejsce w warunku koñcowym w ramach danego kontraktu.
Rzecz jasna, odwo³ania do tych wartoœci nie maj¹ sensu w przypadku warunków pocz¹tkowych, gdy¿ te ewaluowane s¹ zanim sterowanie dojdzie do momentu wykonywania instrukcji wewn¹trz metody, a które mog³yby zmodyfikowaæ stan obiektu. 
Z drugiej strony, co wynika ze specyfiki otrzymywanych powiadomieñ, odczytywanie argumentów jest mo¿liwe tylko w momencie wywo³ywania metody.\\


W kontekœcie sytuacji przedstawionej na listingu \ref{lst:AccountManagerClass} ma sens weryfikacja stanu konta po zakoñczeniu metody \emph{Deposit}. W ramach biblioteki \emph{AsProfiled} mo¿liwe jest zdefiniowanie warunku koñcowego, który weryfikuje t¹ wartoœæ, przy uwzglêdnieniu wartoœci pocz¹tkowej pola \emph{Balance} obiektu typu \emph{Account}.

Kontrakt na³o¿ony na metodê \emph{Deposit} nak³ada warunek okreœlaj¹cy, i¿ po zakoñczeniu wykonywania metody nowa wartoœæ pola \emph{Balance} obiektu typu \emph{Account} musi byæ równa pocz¹tkowej wartoœci tego pola powiêkszonej o wartoœæ \emph{sum}
Odwo³anie do wartoœci pocz¹tkowej danego argumentu odbywa siê poprzez poprzedzenie jego nazwy symbolem \^{}, tutaj \^{}account.Balance. \\


%Zgodnie z tym co zosta³o powiedziane wczeœniej, niezbêdne jest zachowanie stanu obiektu w momencie otrzymania notyfikacji o rozpoczêciu wykonywania metody i odwo³ywanie siê do niego w czasie weryfikacji warunków koñcowych. Dodatkowo, nie wystarczy zachowanie referencji do obiektu. Wynika to z faktu, i¿ pomimo tego, ¿e przekazywanie argumentów do metody odbywa siê poprzez kopiowanie, to kopiowana jest tylko referencja do obiektu, a nie sam obiekt. Oczywiœcie, kopia referencji dalej wskazuje na ten sam obiekt, wiêc zmieniaj¹c stan obiektu przy jej u¿yciu, zmieniany jest oryginalny obiekt.
%Z tego powodu niezbêdne jest kopiowanie poszczególnych wartoœci, do których wystêpuje odwo³anie w warunkach koñcowych.
%Konieczne jest wiêc przeprowadzanie przetwarzania wstêpnego, tzn. w chwili otrzymania powiadomienia o wywo³aniu metody przeprowadzona zostaje analiza zarówno warunków pocz¹tkowych i warunków koñcowych kontraktu. W czasie tej analizy warunek koñcowy sprawdzany jest pod k¹tem wystêpowania elementów odnosz¹cych siê do stanu pocz¹tkowego argumentów funkcji. Nastêpnie argumenty, do których takie odwo³ania wystêpuj¹ poddawane s¹ inspekcji i wy³uskiwana jest wartoœæ sk³adowej obiektu, do którego odniesienie znajduje siê w warunku koñcowym. Ta wartoœæ zapisywana jest w pamiêci podrêcznej aplikacji, do której dostêp jest mo¿liwy w momencie otrzymania powiadomienia o zakoñczeniu wykonywania weryfikowanej metody, kiedy to mo¿e zostaæ u¿yta do weryfikacji warunku koñcowego.\\


