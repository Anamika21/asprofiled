%*********** Rodzia³ 4 ************
\chapter{Omówienie funkcjonalnoœci biblioteki}
W tym rozdziale opisane zosta³y funkcjonalnoœci jakie udostêpnia biblioteka.
Poni¿ej przedstawiony jest ogólny schemat dzia³ania aplikacji, którego poszczególne elementy rozpatrzone s¹ w dalszej czêœci.
\begin{figure}[h]
\centering
\includegraphics[width=5in]{generalflow}
\caption{Schemat dzia³ania aplikacji}
\label{fig:generalFlowDiagram}
\end{figure}
\clearpage
\section{Inspekcja nadzorowanego programu}
Jak to zosta³o wspomniane we wczeœniejszych rozdzia³ach, aplikacja weryfikuj¹ca kontrakty ma postaæ biblioteki COM. Niesie to ze sob¹ pewne konsekwencje. Przede wszystkim biblioteka musi byæ zgodna z konwencj¹ definiowan¹ dla tego typu bibliotek. Szczegó³y dotycz¹ce tego tematu przedstawione zosta³y w kolejnych rozdzia³ach. Drug¹ konsekwencj¹ tego jest koniecznoœæ rejestracji takiej biblioteki w systemie.
Do tego celu u¿ywana jest aplikacja o nazwie regsrv32.exe, która to jest jednym z narzêdzi dostarczanych wraz z platform¹ .NET.
Pobiera ona identyfikator biblioteki, którym jest wartoœæ typu GUID, a nastêpnie  umieszcza w rejestrze systemu klucz sk³adaj¹cy siê z tego identyfikatora i œcie¿ki w systemie plików, okreœlaj¹cej po³o¿enie biblioteki.\\

Rozpoczêcie procesu profilowania/weryfikacji aplikacji odbywa siê poprzez uruchomienie programu z linii poleceñ w odpowiednio przygotowanym œrodowisku.
Etap ten polega na ustawieniu zmiennych œrodowiskowych, instruuj¹cych maszynê wirtualn¹ CLR, aby ta wysy³a³a powiadomienia na temat zdarzeñ zachodz¹cych wewn¹trz uruchamianej aplikacji. 
Odbywa siê to w podany poni¿ej sposób: 

\begin{lstlisting}[label=lst:initProfiling, caption=Inicjalizacja œrodowiska]
SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={GUID}
\end{lstlisting} 

Powy¿sze zmienne s¹ nastêpnie odczytywane przez œrodowisko uruchomieniowe .NET.
Informuj¹ one maszynê wirtualn¹, ¿e ta powinna przesy³aæ informacje o zdarzeniach do biblioteki, której po³o¿enie okreœlanie jest przy wykorzystaniu identyfikatora GUID.\\

Liczba i rodzaj wysy³anych powiadomieñ okreœlany jest wewn¹trz biblioteki profiluj¹cej. W szczegó³ach temat ten opisany jest w kolejnym rozdziale.

\section{Kontrakty}
Podstawowym elementem, dziêki któremu mo¿liwa jest weryfikacja metod, jest  mo¿liwoœæ definiowania kontraktu. Zgodnie z tym co zosta³o powiedziane kontrakty definiujemy za pomoc¹ atrybutów. \\

Atrybuty s¹ to znaczniki o charakterze deklaracyjnym zawieraj¹ce
informacjê o elementach programu (np. klasach, typach wyliczeniowych, metodach) przeznaczon¹ do wykorzystania w trakcie dzia³ania programu.

%Ich odczyt mo¿liwy jest dziêki mechanizmowi zwanym refleksj¹.

Co jest w tym kontekœcie istotne to, i¿ s¹ one pamiêtane jako meta dane danego elementu programu.
Definicja atrybutów jest jedynym elementem, wchodz¹cym bezpoœrednio w sk³ad omawianego rozwi¹zania, który musi znajdowaæ siê po stronie weryfikowanej aplikacji. \\

Atrybuty okreœlaj¹ce kontrakt maj¹ postaæ: 
\begin{lstlisting}[label=AsContract, caption=Ogólna postaæ kontraktu]
AsContract(Warunek pocz¹tkowy, Warunek koñcowy)
\end{lstlisting}
Oba warunki zdefiniowane s¹ poprzez pewne, okreœlone przez u¿ytkownika wyra¿enie. Te z kolei maj¹ postaæ okreœlon¹ przez zadan¹ gramatykê, której definicjê przedstawiono w nastêpnym rozdziale dotycz¹cym implementacji.
Nale¿y tu jednak wspomnieæ, i¿ oba warunki zapisywane s¹ jako ³añcuchy znakowe.
Oznacza to, i¿ przed ewaluacj¹ takiego wyra¿enia musi byæ zaimplementowany mechanizm pozwalaj¹cy na jego analizê sk³adniow¹.
W jej wyniku otrzymywane jest drzewo rozbioru, które nastêpnie poddawane jest ewaluacji. Ostatecznie, otrzymywana jest wartoœæ okreœlaj¹ca czy udekorowana metoda spe³nia za³o¿ony na ni¹ kontrakt w kontekœcie danego wywo³ania.

\section{Metadane}
Metadane w kontekœcie platformy .NET, to dodatkowe informacje opisuj¹ce sk³adowe programu. S¹ usystematyzowanym sposobem reprezentowania wszystkich informacji, których CLI u¿ywa do lokalizowania i ³adowania klas, u³o¿enia obiektów w pamiêci, wywo³ywania metod, translacji jêzyka MSIL do kodu natywnego.

Dane te, emitowane przez kompilator, przechowywane s¹ wewn¹trz ka¿dego wykonywalnego programu w postaci binarnej.

\subsection{Reprezentacja metadanych}
W ramach systemu Windows zdefiniowany jest format plików wykonywalnych - PE (eng. Portable Executables), okreœlaj¹cy strukturê jak¹ musi posiadaæ ka¿dy program, aby móg³ byæ w nim uruchomiony.
%%% RYSUNEK 
Aplikacje przeznaczone na platformê .NET naturalnie równie¿ musz¹ byæ zorganizowane w sposób zgodny z tym standardem.
Jednym z pól w ramach nag³ówka PE jest offset 
%(RVA)
okreœlaj¹cy po³o¿enie zbioru metadanych w ramach pliku wykonywalnego czy biblioteki. 
 
W sk³ad tego zbioru wchodzi piêæ rodzajów strumieni. W tym kontekœcie, przez pojêcie strumieñ, okreœlana jest sekcja w obrêbie metadanych, w której przechowywane s¹ informacje posegregowane wzglêdem ich typu.
Te strumienie to:
\begin{enumerate}
\item \#Strings - zawiera listê napisów, które okreœlaj¹ nazwê programu, metod, parametrów. 
\item \#US (User Strings) - zawiera tablicê wszystkich sta³ych ³añcuchowych definiowanych przez u¿ytkownika. 
\item \#GUID - przechowuje listê wszystkich u¿ytych w aplikacji 128 bitowych wartoœci GUID, m.in. t¹ która jednoznacznie identyfikuje aplikacjê  

\item \#~ - ten strumieñ jest tablic¹ tablic. Ka¿da tablica nadrzêdna identyfikowana przy pomocy pojedynczego bajtu o wartoœci od 0x00 do 0x29. Tablice wewnêtrzne opisuj¹ metody, pola, parametry, typy.
\item \#Blob - zawiera ci¹gi danych binarnych, które nie mog¹ byæ przedstawione w prosty sposób jako napisy. Dane te wykorzystywane s¹ do opisywania sygnatur metod.
\end{enumerate}

Metadane przechowuj¹ informacje na temat typów definiowanych w ramach programu (klasy, struktury, interfejsy), globalnych funkcji i zmiennych. Ka¿da z tych abstrakcyjnych encji identyfikowana jest przez wartoœæ typu mdToken (metadata token). Jest ona u¿ywana przez mechanizmy odczytuj¹ce metadane do okreœlenia  po³o¿enia w pamiêci informacji na ich temat.

Token metadanych ma postaæ czterobajtowej wartoœci. Najbardziej znacz¹cy bajt   okreœla typ tokenu, pozosta³e okreœlaj¹ po³o¿enie pozosta³ych informacji w tablicy metadanych.
Dla przyk³adu, wartoœæ 1 przechowywana w MSB (most significant byte) oznacza, i¿ token jest typu mdTypeRef, który oznacza referencjê do typu, a informacje na jego temat s¹ przechowywane w tablicy TypeRef.


Pozosta³e, mniej znacz¹ce bajty, oznaczaj¹ identyfikator rekordu (record identifier - RID) i zawieraj¹ w sobie indeks do wiersza w/w tablicy, która okreœlona jest przez wartoœæ najbardziej znacz¹cego bajtu.\\
Przyk³adowo, token o wartoœci 0x02000007 odnosi siê do siódmego wiersza tablicy TypeRef. Podobnie, wartoœæ 0x0400001A oznacza odwo³anie do wiersza dwudziestego szóstego tabliy FieldDef.
Wiersz zerowy ka¿dej z powy¿szych tablic nigdy nie zawiera w sobie danych, wiêc jeœli identyfikator RID jest równy zeru, to znaczy to, ¿e token jest pusty, ma wartoœæ nil. Taki token zdefiniowany jest dla ka¿dego typu encji, np. wartoœæ 0x10000000 okreœla pusty token mdTypeRefNil.


W poni¿szej tabeli znajduj¹ siê typy tokenów wykorzystywane w ramach aplikacji, typy które opisuj¹ oraz nazwy tablic metadanych. Wszystkie tokeny s¹ pochodnymi typu bazowego - mdToken.

\begin{center}
    \begin{longtable}{ |c | c | p{6cm} |}
    \hline
Typ tokenu & Nazwa tablicy z metadanymi & Opis \\ \hline

mdTypeDef &
TypeDef &
Token odnosz¹cy siê do typów referencyjnych (klasy i interfejsy) i wartoœciowych (struktury) \\ \hline
%Type declaration: Declaration of either a runtime reference type (class or %interface) or a value type. \\ \hline


mdMethodDef &
MethodDef &
Token odnosz¹cy do informacji opisuj¹cych metody bêd¹ce czêœci¹ klasy lub interfejsu \\ \hline

mdParamDef &
ParamDef &
Typ tokenu, którego wartoœci odnosz¹ siê do informacji okreœlaj¹cych parametry metod \\ \hline

mdFieldDef &
FieldDef &
Odniesienie do metadanych dotycz¹cych sk³adowych  wchodz¹cych w sk³ad klas, interfejsów \\ \hline

mdCustomAttribute &
CustomAttribute &
Zawiera odniesienie do metadanych atrybutów \\ \hline


	\end{longtable}
\end{center}

%used to encode the keyword instance in the calling convention, see §15.3
%EXPLICITTHIS = 0x40, used to encode the keyword explicit in the calling %convention, see §15.3
%DEFAULT = 0x0, used to encode the keyword default in the calling convention, %see §15.3
%VARARG = 0x5, used to encode the keyword vararg in the calling convention, see %§15.3
%used to indicate that the method has one or more generic parameters.
%The first byte of the Signature holds bits for HASTHIS, EXPLICITTHIS and %calling convention (DEFAULT, VARARG,
%or GENERIC). These are ORed together.

%GenParamCount is the number of generic parameters for the method. This is a %compressed int32. [Note: For
%generic methods, both MethodDef and MemberRef shall include the GENERIC calling %convention, together with
%GenParamCount; these are significant for binding—they enable the CLI to %overload on generic methods by the
%number of generic parameters they include. end note]
%ParamCount is an integer that holds the number of parameters (0 or more). It %can be any number between 0
%and 0x1FFFFFFF. The compiler compresses it too (see Partition II Metadata %Validation) – before storing into
%the 'blob' (ParamCount counts just the method parameters – it does not include %the method’s return type)
%The RetType item describes the type of the method’s return value (§23.2.11)
%The Param item describes the type of each of the method’s parameters. There %shall be ParamCount instances
%of the Param item (§23.2.10)



%The value of the first byte of a Signature 'blob' indicates what kind of %Signature it is. Its lowest 4 bits hold one
%of the following: C, DEFAULT, FASTCALL, STDCALL, THISCALL, or VARARG (whose %values are defined in §23.2.3),
%which qualify method signatures; FIELD, which denotes a field signature (whose %value is defined in §23.2.4); or
%PROPERTY, which denotes a property signature (whose value is defined in %§23.2.5). This subclause defines the
%binary 'blob' format for each kind of Signature. In the syntax diagrams that %accompany many of the definitions,
%Partition II 153
%shading is used to combine into a single diagram what would otherwise be %multiple diagrams; the
%accompanying text describes the use of shading.
%Signatures are compressed before being stored into the Blob heap (described %below) by compressing the
%integers embedded in the signature. The maximum encodable integer is 29 bits %long, 0x1FFFFFFF. The
%compression algorithm used is as follows (bit 0 is the least significant bit):
%• If the value lies between 0 (0x00) and 127 (0x7F), inclusive, encode as a %one-byte integer (bit 7 is
%clear, value held in bits 6 through 0)
%• If the value lies between 28 (0x80) and 214 – 1 (0x3FFF), inclusive, encode %as a 2-byte integer
%with bit 15 set, bit 14 clear (value held in bits 13 through 0)
%• Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 %clear (value held in bits 28
%through 0)
%• A null string should be represented with the reserved single byte 0xFF, and %no following data


\section{Odczytywanie wartoœci argumentów metod}

%Kolejnym krokiem na drodze do ewaluacji kontraktów jest odczyt wartoœci %argumentów przekazywanych do metody w trakcie jej wywo³ania.
Dziêki informacjom zawartym w metadanych, mo¿liwe jest okreœlenie liczby i typów parametrów przekazywanych do metod. S¹ to dane statyczne, w tym sensie, ¿e s¹ one sta³e w ramach raz zdefiniowanego programu. Z drugiej strony, wartoœci parametrów mog¹ byæ inne dla ka¿dego wywo³ania metody, tak wiêc nie mog¹ w ¿aden sposób stanowiæ czêœci metadanych. Musi wiêc zatem istnieæ osobny mechanizm pozwalaj¹cy na realizacjê tego zadania. \\
Okazuje siê, ¿e w momencie wysy³ania powiadomienia o zajœciu zdarzenia wywo³ania metody, maszyna wirtualna .NET wype³nia strukturê \emph{\_COR\_PRF\_FUNCTION\_ARGUMENT\_INFO}, która jest przekazywana do odbiorcy. 
Jej definicja przedstawia siê w sposób nastêpuj¹cy:
\begin{lstlisting}[label=CorPrfFunctionArgumentInfo]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_INFO {
    ULONG numRanges;
    ULONG totalArgumentSize;
    COR_PRF_FUNCTION_ARGUMENT_RANGE ranges[1];
} COR_PRF_FUNCTION_ARGUMENT_INFO;
\end{lstlisting}
Objaœnienia:
\begin{itemize}
\item \emph{numRanges} - Liczba bloków pamiêci, wewn¹trz których znajduj¹ siê wartoœci argumentów. Okreœla liczbê elementów tablicy typu \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}
\item \emph{totalArgumentSize} - Ca³kowita d³ugoœæ wszystkich argumentów wyra¿ona w bajtach.
\item \emph{ranges} Tablica obiektów typu \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}, z których ka¿da reprezentuje jeden blok pamiêci, gdzie zawarte s¹ wartoœci argumentów metody
\end{itemize}
Struktura ta reprezentuje wartoœci argumentów metody, zgodnie z porz¹dkiem od lewej do prawej.
Typ \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE }u¿yty w ramach tej struktury okreœlony jest jak nastêpuje:
\begin{lstlisting}[label=lst:CorPrfFunctionArgumentRange]
typedef struct _COR_PRF_FUNCTION_ARGUMENT_RANGE {
    UINT_PTR startAddress;
    ULONG length;
} COR_PRF_FUNCTION_ARGUMENT_RANGE;
\end{lstlisting}
,gdzie\\
\begin{itemize}
\item startAddress - Adres pocz¹tku bloku.
\item length - Wielkoœæ bloku pamiêci.
\end{itemize}

Te dane w po³¹czeniu z informacj¹ o typie argumentu pozwalaj¹ na poprawny odczyt argumentów metody. 

\section{Wartoœci zwracane}
\label{sec:chapter4:section5}

Kolejnym elementem jest mo¿liwoœæ weryfikacji kontraktów zawieraj¹cych w sobie odniesienia do wartoœci zwracanej przez metodê.\\

W dalszych przyk³adach wykorzystano klasê \emph{Account} reprezentuj¹c¹ konto bankowe, której czêœciowa definicja zawarta jest poni¿ej.
\begin{lstlisting}[label=AccountClass, caption=Klasa Account]
class Account {
 // Identyfikator konta
 public long AccountId;
 // Stan œrodków na koncie
 public int Balance;
 // Nazwisko posiadacza
 public string OwnerName;
 
 ...
}
\end{lstlisting}


Dodatkowo, niech dana bêdzie klasa \emph{AccountManager} definiuj¹ca operacje na obiektach typu \emph{Account}.

\begin{lstlisting}[label=AccountClass, caption=Klasa AccountManager]
class AccountManager {
 public Account ChangeOwnerName(Account account, string newName) {
  // Wywo³anie metody rejestruj¹cej bie¿¹c¹ operacjê w bazie danych
  // Zwraca zapisan¹ wartoœæ
  account.OwnerName = Database.SetAccountOwnerInternal(account.accountId, newName);
  return account; 
 }
}
\end{lstlisting}

Metoda ta zwraca obiekt typu \emph{Account}, z uaktualnion¹ wartoœci¹ \emph{OwnerName} mówi¹c¹ o dostêpnych œrodkach. W celu sprawdzenia poprawnoœci dzia³ania tej funkcjonalnoœci mo¿liwe jest na³o¿enie odpowiedniego kontraktu  na metodê \emph{ChangeOwnerName}. Przy u¿yciu atrybutów z biblioteki \emph{AsProfiled} mo¿liwa jest inspekcja obiektu zwracanego z metody. Warto zaznaczyæ, ¿e takie odniesienia maj¹ tylko sens przy warunkach koñcowych, po odebraniu notyfikacji o zdarzeniu opuszczenia metody.
W ramach atrybutów \emph{AsContract} odwo³anie do wartoœci zwracanej odbywa siê poprzez u¿ycie  identyfikatora \emph{@returnValue}. Maj¹c to na uwadze, warunek koñcowy, sprawdzaj¹cy czy nazwisko posiadacza rzeczywiœcie zosta³o uaktualnione, na³o¿ony na t¹ metodê, móg³by mieæ nastêpuj¹c¹ postaæ:

\begin{lstlisting}[label=AccountClass, caption=Sprawdzenie poprawnoœci operacji uaktualnienia nazwiska posiadacza konta]
 [AsContract(null, "@returnValue.OwnerName == newName")]
 public Account ChangeOwnerName(Account account, string newName) {
  account.OwnerName = Database.SetAccountOwnerInternal(account.accountId, newName);
  return account; 
 }
}
\end{lstlisting}

Sposób odczytu wartoœci zwracanej jest analogiczny do odczytywania wartoœci parametrów metody. W tym wypadku, odbiorca zdarzenia otrzymuje dostêp do pojedynczego obiektu typu \emph{COR\_PRF\_FUNCTION\_ARGUMENT\_RANGE}, który zawiera w sobie informacje na temat po³o¿enia wartoœci zwracanej w pamiêci.

\section{Wartoœci pocz¹tkowe}

Termin wartoœci pocz¹tkowe odnosi siê do stanu argumentów w momencie wywo³ania metody. Zgodnie z za³o¿eniami z rozdzia³u pierwszego, biblioteka powinna udostêpniaæ funkcjonalnoœæ definiowania kontraktów z³o¿onych z odwo³añ do pocz¹tkowych wartoœci obiektów. Naturalnie, stan obiektów mo¿e ulec zmianie w czasie dzia³ania metody, nale¿a³o wiêc przedsiêwzi¹æ kroki umo¿liwiaj¹ce tego rodzaju odwo³ania do pocz¹tkowych wartoœci obiektów. 

Jedyn¹ sytuacj¹ jak¹ nale¿y rozwa¿yæ jest przypadek, w którym odwo³ania do wartoœci pocz¹tkowych ma miejsce w warunku koñcowym w ramach danego kontraktu.
Rzecz jasna, odwo³ania do tych wartoœci nie maj¹ sensu w przypadku warunków pocz¹tkowych, gdy¿ te ewaluowane s¹ zanim sterowanie dojdzie do momentu wykonywania instrukcji wewn¹trz metody, a które mog³yby zmodyfikowaæ stan obiektu. 
Z drugiej strony, co wynika ze specyfiki otrzymywanych powiadomieñ, odczytywanie argumentów jest mo¿liwe tylko w momencie wywo³ywania metody.\\


Niech dana bêdzie metoda zwiêkszaj¹ca bilans konta bankowego po wp³yniêciu na nie œrodków.

\begin{lstlisting}[label=InitialValues, caption=Metoda zwiêkszaj¹ca bilans konta]

class AccountManager {
 public Account Deposit(Account account, int sum) {
  // Wywo³anie metody zapisuj¹cej do bazy danych nowy stan konta o danym
  // identyfikatorze
  // Zwraca uaktualniony obiekt typu Account
  int newBalance = Database.DepositInternal(AccountId, sum);
  account.Balance = newBalance;
  return account; 
 }
}
\end{lstlisting}

W tej sytuacji ma sens weryfikacja stanu konta po zakoñczeniu metody \emph{Deposit}. W ramach biblioteki \emph{AsProfiled} mo¿liwe jest zdefiniowanie warunku koñcowego, który weryfikuje t¹ wartoœæ, przy uwzglêdnieniu wartoœci pocz¹tkowej elementu Balance.
W tej konkretnej sytuacji bêdzie mia³ on nastêpuj¹c¹ postaæ:
\begin{lstlisting}[label=InitialValuesConstrained, caption=Odwo³anie do wartoœci pocz¹tkowej]
[AsContract(null, "account.Balance == ^account.Balance + sum")]
public Account Deposit(Account account, int sum) {
 int newBalance = Database.DepositInternal(AccountId, sum);
 account.Balance = newBalance;
 return account; 
}
\end{lstlisting}

Kontrakt ten nak³ada warunek okreœlaj¹cy, i¿ po spe³niony po zakoñczeniu wykonywania metody nowa wartoœæ pola \emph{Balance} obiektu typu \emph{Account} musi byæ równa pocz¹tkowej wartoœci tego pola powiêkszonej o wartoœæ \emph{sum}
Odwo³anie do wartoœci pocz¹tkowych danego argumentu odbywa siê poprzez poprzedzenie jego nazwy symbolem \^{}, tutaj \^{}account.Balance. \\


Zgodnie z tym co zosta³o powiedziane wczeœniej, niezbêdne jest zachowanie stanu obiektu w momencie otrzymania notyfikacji o rozpoczêciu wykonywania metody i odwo³ywanie siê do niego w czasie weryfikacji warunków koñcowych. Dodatkowo, nie wystarczy zachowanie referencji do obiektu. Wynika to z faktu, i¿ pomimo tego, ¿e przekazywanie argumentów do metody odbywa siê poprzez kopiowanie, to kopiowana jest tylko referencja do obiektu, a nie sam obiekt. Oczywiœcie, kopia referencji dalej wskazuje na ten sam obiekt, wiêc zmieniaj¹c stan obiektu przy jej u¿yciu, zmieniany jest oryginalny obiekt.
Z tego powodu niezbêdne okazuje siê kopiowanie poszczególnych wartoœci do których wystêpuje odwo³anie w warunkach koñcowych.
Konieczne jest wiêc przeprowadzanie przetwarzania wstêpnego, tzn. w chwili otrzymania powiadomienia o wywo³aniu metody przeprowadzona zostaje analiza zarówno warunków pocz¹tkowych i warunków koñcowych kontraktu. W czasie tej analizy warunek koñcowy sprawdzany jest pod k¹tem wystêpowania elementów odnosz¹cych siê do stanu pocz¹tkowego argumentów funkcji. Nastêpnie argumenty, do których takie odwo³ania wystêpuj¹ poddawane s¹ inspekcji i wy³uskiwana jest wartoœæ sk³adowej obiektu, do którego odniesienie znajduje siê w warunku koñcowym. Ta wartoœæ zapisywana jest w pamiêci podrêcznej aplikacji, do której dostêp jest mo¿liwy w momencie otrzymania powiadomienia o zakoñczeniu wykonywania weryfikowanej metody, kiedy to mo¿e zostaæ u¿yta do weryfikacji warunku koñcowego.\\

%\section{Ograniczenia}

