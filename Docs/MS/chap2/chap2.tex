\chapter{Programowanie kontraktowe}
W tym rozdziale zosta³a przybli¿ona specyfika programowania kontraktowego.
Programowanie kontraktowe jest metodologi¹ sprawdzania poprawnoœci oprogramowania. 
\section{Historia}
Koncepcja ta ma korzenie w pracach nad formaln¹ weryfikacj¹ programów, formaln¹ specyfikacj¹ oraz zwi¹zanych z logik¹ Hoara.
Wszystkie z powy¿szych d¹¿¹ do dowodzenia poprawnoœci programów komputerowych, a tym samym przyczyniaj¹ siê podnoszenia ich jakoœci.
Nie inaczej jest w przypadku programowanie kontraktowego. 
Po raz pierwszy w obecnej postaci wprowadzi³ je Bertrand Meyer w 1986 roku przy okazji projektu jêzyka programowania Eiffel. 
Do dnia dzisiejszego powsta³o wiele ró¿nych ró¿nych implementacji tej koncepcji.
Czeœæ jêzyków programowania ma wbudowane mechanizmy pozwalaj¹ce na definiowanie i sprawdzanie poprawnoœci kontraktów. Do tej grupy zaliczamy:
\begin{packed_item}
\item Cobra
\item Eiffel
\item D
\item jêzyki oparte na platformie .NET w wersji 4.0
\end{packed_item}
Drug¹ grupê stanowi¹ jêzyki dla których powsta³y nak³adki umo¿liwiaj¹ce ten rodzaj weryfikacji. Ta grupa jest znacznie bardziej obszerna i obejmuje wiêkszoœæ znacz¹cych jêzyków programowania, takich jak :
\begin{packed_item}
\item C/C++, 
\item C\#
\item Java 
\item Javascript
\item Perl
\item Python
\item Ruby
\end{packed_item}
Omawiana biblioteka nale¿y do drugiej grupy rozwi¹zañ.
\section{Opis}
Ten rodzaj programowania zak³ada, ¿e elementy programu powinny odnosiæ siê do siebie na zasadzie kontraktów, czyli:
\begin{itemize}
\item Ka¿dy element powinien zapewniaæ okreœlon¹ funkcjonalnoœæ i wymagaæ œciœle okreœlonych œrodków do wykonania polecenia.
\item Klient mo¿e u¿yæ funkcjonalnoœci, o ile spe³ni zdefiniowane wymagania.
\item Kontrakt opisuje wymagania stawiane obu stronom.
\item Element zapewniaj¹cy funkcjonalnoœæ powinien przewidzieæ sytuacje wyj¹tkowe, a klient powinien je rozpatrzyæ.
\end{itemize}

Koncepcja ta polega na zawieraniu swego rodzaju umowy pomiêdzy dostawc¹ funkcjonalnoœci i klientami. W ogólnym przypadku poprzez dostawców rozumiemy klasy lub metody zawarte w programie, klientem zaœ jest ka¿dy kto z tych encji korzysta. \\
Dla danej klasy kontrakt definiowany jest jako niezmiennik, to znaczy,
warunek jaki musi byæ spe³niony przed i po wywo³aniu dowolnej publicznej metody w obrêbie tej klasy. \\
Z kolei dla metod, kontrakt definiowany jest przy pomocy warunków pocz¹tkowego i koñcowego, gdzie ten pierwszy specyfikuje jakie za³o¿enia powinny byæ spe³nione w momencie wywo³ania metody, a drugi okreœla stan aplikacji po jej zakoñczeniu.\\ 

Rozwi¹zanie, które jest tu opisywane skupia siê na drugim rodzaju kontraktów.
W jêzyku programowania Eiffel, sk¹d wywodzi siê ca³a idea, tego rodzaju kontrakty opisywane s¹ w sposób nastêpuj¹cy: \\

\begin{lstlisting}[label=DesignByContract, caption=Programowanie kontraktowe]
NazwaMetody (deklaracja argumentów) is
require
 -- warunek pocz¹tkowy
do
 -- cia³o metody
ensure
 -- warunek pocz¹tkowy
end 
\end{lstlisting}
Dla ilustracji, poni¿ej zamieszczono definicjê klasy \emph{ACCOUNT}, reprezentuj¹cej konto u¿ytkownika w banku. W ramach konta mo¿na przeprowadziæ operacje wp³aty i wyp³aty œrodków. Dla metod odpowiadaj¹cym tym czynnoœciom, zdefiniowane zosta³y warunki pocz¹tkowe i koñcowe. Zgodnie z powy¿szym, warunki zosta³y umieszczone w ramach bloków \emph{require} i \emph{ensure}  

\begin{lstlisting}[label=DesignByContractExample, caption=Kontrakty w jêzyku Eiffel]
class ACCOUNT feature
 balance: INTEGER
 minimum_balance: INTEGER is 1000
 
 deposit (sum: INTEGER) is
 -- Zdeponowanie kwoty na koncie.
 require
  sum >= 0
 do
  add (sum)
 ensure
  balance = old balance + sum
 end 
    
 withdraw (sum: INTEGER) is
 -- Wyp³ata pewnej sumy z konta. 
 require
  sum >= 0
  sum <= balance - minimum_balance 
 do
  add (-sum)
 ensure
  balance = old balance - sum 
 end

 feature {NONE}
  add (sum: INTEGER) is
  -- Dodanie pewnej kwoty do sumy zdeponowanej na koncie.
  do
   balance := balance + sum
  end
end -- class ACCOUNT 
\end{lstlisting}

Przy budowie prezentowanej aplikacji wykorzystano cechê szczególn¹ platformy .NET, a w szczególnoœci jêzyka C\#, jak¹ jest mo¿liwoœæ dekorowania metod atrybutami. Ten element jêzyka bêdzie dok³adniej opisany w dalszej czêœci pracy, przy omawianiu funkcjonalnoœci biblioteki. W tym momencie wystarczy przyj¹æ, i¿ atrybuty te staj¹ siê czêœci¹ meta informacji o danej metodzie, co z kolei mo¿e byæ wykorzystywane przy jej inspekcji.
Dla ilustracji, poni¿ej zosta³a zademonstrowana ogólna postaæ zapisu kontraktów jako atrybuty w jêzyku C\#:

\begin{lstlisting}[label=ContractDefinition, caption=Definicja kontraktu]
[NazwaAtrybutuDefiniuj¹cegoKontrakt( warunek pocz¹tkowy, warunek koñcowy )]
NazwaMetody( deklaracja argumentów )
{
  -- definicja metody
}
\end{lstlisting}
